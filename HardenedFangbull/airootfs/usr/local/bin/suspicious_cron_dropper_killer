#!/bin/bash

# Suspicious Cron Dropper Killer - Hardened Fangbull (Optimized)
# Advanced detection and elimination of malicious cron jobs and scheduled tasks
# Performance optimized with efficient logging

# Load optimized log manager
source /usr/local/bin/fangbull-log-manager 2>/dev/null || {
    echo "Error: fangbull-log-manager not found" >&2
    exit 1
}

# Configuration
COMPONENT_NAME="cron_dropper"
CACHE_FILE="/var/log/fangbull-ids/cron_dropper.cache"
SAMPLE_DIR="/var/log/fangbull-ids/cron_samples"
INTEL_DB="/var/log/fangbull-ids/cron_intel.db"
SCAN_INTERVAL=60      # Increased from 45 to reduce CPU load
SEVERITY_THRESHOLD=75 # Increased threshold to reduce false positives
YARA_RULES_DIR="/var/log/fangbull-ids/cron_rules"
MAX_CONCURRENT_SCANS=3 # Limit concurrent operations

# Performance counters
declare -A PERF_COUNTERS=(
    ["scans_completed"]=0
    ["threats_detected"]=0
    ["false_positives"]=0
    ["cache_hits"]=0
)

# Create required directories
mkdir -p "$(dirname "$CACHE_FILE")" 2>/dev/null
mkdir -p "$SAMPLE_DIR" 2>/dev/null
mkdir -p "$YARA_RULES_DIR" 2>/dev/null

# Optimized logging function
log_message() {
    local message="$1"
    local level="${2:-INFO}"
    fangbull_log "$level" "$COMPONENT_NAME" "$message"
}

# Create basic YARA rules if they don't exist
create_default_yara_rules() {
    if [ ! -f "$YARA_RULES_DIR/malicious_cron.yar" ]; then
        cat > "$YARA_RULES_DIR/malicious_cron.yar" << 'EOF'
rule Suspicious_Cron_Patterns {
    strings:
        $curl_wget1 = "curl" nocase
        $curl_wget2 = "wget" nocase
        $pipe_sh1 = "| sh" nocase
        $pipe_sh2 = "| bash" nocase
        $pipe_sh3 = "|sh" nocase
        $pipe_sh4 = "|bash" nocase
        $base64_1 = "base64 -d" nocase
        $base64_2 = "base64 --decode" nocase
        $base64_3 = "`echo" nocase
        $base64_pattern = /[A-Za-z0-9+\/]{30,}={0,2}/
        $obfuscation1 = "eval" nocase
        $obfuscation2 = "exec" nocase
        $network1 = "/dev/tcp/" nocase
        $network2 = "nc " nocase
        $network3 = "netcat" nocase
        $network4 = "socat" nocase
        $privesc1 = "chmod +s" nocase
        $privesc2 = "chmod u+s" nocase
        $privesc3 = "chmod 4" nocase
        $privesc4 = "sudo" nocase
    condition:
        (any of ($curl_wget*) and any of ($pipe_sh*)) or
        any of ($base64*) or
        any of ($obfuscation*) or
        any of ($network*) or
        any of ($privesc*)
}

rule Suspicious_Cron_Paths {
    strings:
        $path1 = "/tmp/" nocase
        $path2 = "/dev/shm/" nocase
        $path3 = "/var/tmp/" nocase
        $path4 = "~/.cache/" nocase
        $path5 = "/run/user/" nocase
        $path6 = "/.ssh/" nocase
    condition:
        any of them
}

rule Suspicious_Cron_Timing {
    strings:
        $timing1 = "* * * * *" // every minute
        $timing2 = "*/1 * * * *" // every minute
        $timing3 = "*/2 * * * *" // every 2 minutes
        $timing4 = "*/5 * * * *" // every 5 minutes
        $timing5 = "@reboot" // at reboot
    condition:
        any of them
}
EOF
    fi
}

# Suspicious locations to monitor - comprehensive list
SUSPICIOUS_DIRS=(
    "/tmp"
    "/var/tmp"
    "/dev/shm"
    "/run/shm"
    "/run/user"
)

# Home directories will be handled separately
HOME_DIRS=$(find /home -maxdepth 1 -type d 2>/dev/null)

# Suspicious cron patterns to detect
CRON_PATTERNS=(
    "\.cron$"
    "\.crond$"
    "crontab$"
    "\.at$"
    "\.timer$"
    "\.job$"
    "\.task$"
    "\.sched$"
)

# Suspicious content patterns
SUSPICIOUS_PATTERNS=(
    "curl.*\|.*sh"
    "wget.*\|.*sh"
    "curl.*\|.*bash"
    "wget.*\|.*bash"
    "curl.*\>.*\.sh"
    "wget.*\>.*\.sh"
    "base64.*-d"
    "base64.*--decode"
    "eval.*\("
    "exec.*\("
    "/dev/tcp/"
    "nc -e"
    "netcat -e"
    "socat"
    "chmod.*\+s"
    "chmod.*4"
    "chmod.*2"
    "chown.*root"
    "\.ssh/authorized_keys"
    "/etc/passwd"
    "/etc/shadow"
    "/etc/sudoers"
)

# Cache of known clean and malicious files
declare -A CLEAN_CACHE
declare -A MALICIOUS_CACHE

# Load cache if it exists
load_cache() {
    if [ -f "$CACHE_FILE" ]; then
        while IFS=: read -r type path hash; do
            if [ "$type" = "CLEAN" ]; then
                CLEAN_CACHE["$path"]="$hash"
            elif [ "$type" = "MALICIOUS" ]; then
                MALICIOUS_CACHE["$path"]="$hash"
            fi
        done < "$CACHE_FILE"
    fi
}

# Save cache periodically
save_cache() {
    # Create temp file first to avoid race conditions
    local tmp_file=$(mktemp)
    
    # Save clean cache (limit to 1000 entries)
    local count=0
    for path in "${!CLEAN_CACHE[@]}"; do
        if [ $count -lt 1000 ]; then
            echo "CLEAN:$path:${CLEAN_CACHE[$path]}" >> "$tmp_file"
            count=$((count + 1))
        fi
    done
    
    # Save malicious cache (keep all entries)
    for path in "${!MALICIOUS_CACHE[@]}"; do
        echo "MALICIOUS:$path:${MALICIOUS_CACHE[$path]}" >> "$tmp_file"
    done
    
    # Atomic update
    mv "$tmp_file" "$CACHE_FILE" 2>/dev/null
}

# Update threat intelligence database
update_threat_intel() {
    local file=$1
    local hash=$2
    local score=$3
    local reason=$4
    local timestamp=$(date -Iseconds)
    
    # Create temp file for atomic write
    local tmp_file=$(mktemp)
    
    # Use jq if available for proper JSON handling
    if command -v jq >/dev/null 2>&1; then
        if [ -f "$INTEL_DB" ]; then
            jq --arg hash "$hash" \
               --arg file "$file" \
               --arg score "$score" \
               --arg reason "$reason" \
               --arg time "$timestamp" \
            '.threats[$hash] = {
                "file": $file,
                "score": ($score|tonumber),
                "reason": $reason,
                "timestamp": $time
             } | .metadata.last_update = $time' \
            "$INTEL_DB" > "$tmp_file" 2>/dev/null
        else
            echo "{\"threats\":{\"$hash\":{\"file\":\"$file\",\"score\":$score,\"reason\":\"$reason\",\"timestamp\":\"$timestamp\"}},\"metadata\":{\"last_update\":\"$timestamp\"}}" > "$tmp_file"
        fi
    else
        # Simple fallback if jq not available
        echo "{\"threats\":{\"$hash\":{\"file\":\"$file\",\"score\":$score,\"reason\":\"$reason\",\"timestamp\":\"$timestamp\"}},\"metadata\":{\"last_update\":\"$timestamp\"}}" > "$tmp_file"
    fi
    
    # Atomic update
    if [ -s "$tmp_file" ]; then
        mv "$tmp_file" "$INTEL_DB"
    else
        rm -f "$tmp_file"
    fi
}

# Optimized cache management
manage_performance_cache() {
    manage_cache "$CACHE_FILE"
    cleanup_samples "$SAMPLE_DIR"
    
    # Update performance counters every 100 scans
    if [ $((${PERF_COUNTERS["scans_completed"]} % 100)) -eq 0 ]; then
        local stats_file="/var/log/fangbull-ids/cron_performance.stats"
        {
            echo "Scans Completed: ${PERF_COUNTERS["scans_completed"]}"
            echo "Threats Detected: ${PERF_COUNTERS["threats_detected"]}"
            echo "Cache Hits: ${PERF_COUNTERS["cache_hits"]}"
            echo "False Positives: ${PERF_COUNTERS["false_positives"]}"
            echo "Last Update: $(date)"
        } > "$stats_file"
    fi
}

# Fast hash-based cache lookup
check_file_cache() {
    local file="$1"
    local file_hash=$(sha256sum "$file" 2>/dev/null | cut -d' ' -f1)
    
    if [ -f "$CACHE_FILE" ] && grep -q "^$file_hash" "$CACHE_FILE" 2>/dev/null; then
        PERF_COUNTERS["cache_hits"]=$((${PERF_COUNTERS["cache_hits"]} + 1))
        return 0  # File already processed
    fi
    
    return 1  # File needs processing
}

# Add file to cache
add_to_cache() {
    local file="$1"
    local result="$2"
    local file_hash=$(sha256sum "$file" 2>/dev/null | cut -d' ' -f1)
    
    echo "$file_hash:$result:$(date +%s)" >> "$CACHE_FILE"
}

# Optimized suspicious cron detection with caching
is_suspicious_cron() {
    local file=$1
    
    # Quick cache check first
    if check_file_cache "$file"; then
        return 1  # Already processed, assume clean
    fi
    
    # Skip if file no longer exists
    if [ ! -f "$file" ]; then
        return 1
    fi
    
    # Skip large files
    local file_size=$(stat -c%s "$file" 2>/dev/null)
    if [ -z "$file_size" ] || [ "$file_size" -gt 1048576 ]; then  # 1MB max
        return 1
    fi
    
    # Get file hash for cache lookup
    local hash=$(sha256sum "$file" 2>/dev/null | cut -d' ' -f1)
    if [ -z "$hash" ]; then
        return 1
    fi
    
    # Check cache first
    if [ "${CLEAN_CACHE["$file"]}" = "$hash" ]; then
        return 1
    fi
    
    if [ -n "${MALICIOUS_CACHE["$file"]}" ]; then
        return 0
    fi
    
    # Calculate threat score
    local threat_score=0
    local threat_reason=""
    
    # Check file location - files in suspicious locations get base score
    for dir in "${SUSPICIOUS_DIRS[@]}"; do
        if [[ "$file" == "$dir"* ]]; then
            threat_score=$((threat_score + 30))
            threat_reason="${threat_reason}Suspicious location ($dir); "
            break
        fi
    done
    
    # Check if it's in a hidden directory in home
    if [[ "$file" == "/home/"*"/."* ]]; then
        threat_score=$((threat_score + 25))
        threat_reason="${threat_reason}Hidden location in home directory; "
    fi
    
    # Check file permissions
    local perms=$(stat -c %a "$file" 2>/dev/null)
    if [ "$perms" = "777" ] || [ "$perms" = "755" ] || [ "$perms" = "4755" ]; then
        threat_score=$((threat_score + 15))
        threat_reason="${threat_reason}Suspicious permissions ($perms); "
    fi
    
    # Check file owner
    local owner=$(stat -c %U "$file" 2>/dev/null)
    if [ "$owner" != "root" ] && [ "$owner" != "$(whoami)" ]; then
        threat_score=$((threat_score + 15))
        threat_reason="${threat_reason}Suspicious owner ($owner); "
    fi
    
    # Check for suspicious content
    local suspicious_patterns=$(printf "|%s" "${SUSPICIOUS_PATTERNS[@]}")
    suspicious_patterns=${suspicious_patterns:1}  # Remove leading |
    
    if grep -q -E "$suspicious_patterns" "$file" 2>/dev/null; then
        # Find which patterns matched for better reporting
        for pattern in "${SUSPICIOUS_PATTERNS[@]}"; do
            if grep -q -E "$pattern" "$file" 2>/dev/null; then
                threat_score=$((threat_score + 20))
                threat_reason="${threat_reason}Suspicious pattern: $pattern; "
            fi
        done
    fi
    
    # Check for base64 encoded data
    if grep -q -E "[A-Za-z0-9+/]{30,}={0,2}" "$file" 2>/dev/null; then
        threat_score=$((threat_score + 25))
        threat_reason="${threat_reason}Base64 encoded data; "
    fi
    
    # Check for IP addresses and domain names
    if grep -q -E "\b([0-9]{1,3}\.){3}[0-9]{1,3}\b" "$file" 2>/dev/null; then
        threat_score=$((threat_score + 15))
        threat_reason="${threat_reason}Contains IP addresses; "
    fi
    
    # Check for common C2 domains
    if grep -q -E "(\.onion|pastebin\.com|github\.io|raw\.githubusercontent)" "$file" 2>/dev/null; then
        threat_score=$((threat_score + 20))
        threat_reason="${threat_reason}Contains suspicious domains; "
    fi
    
    # Check for suspicious cron timing patterns
    if grep -q -E "((\*|/[0-9]+) ){4}(\*|/[0-9]+)" "$file" 2>/dev/null; then
        threat_score=$((threat_score + 10))
        threat_reason="${threat_reason}Frequent execution schedule; "
    fi
    
    # Check for @reboot directive
    if grep -q "@reboot" "$file" 2>/dev/null; then
        threat_score=$((threat_score + 15))
        threat_reason="${threat_reason}Runs at system boot; "
    fi
    
    # Run YARA scan if available
    if command -v yara >/dev/null 2>&1 && [ -d "$YARA_RULES_DIR" ]; then
        for rule_file in "$YARA_RULES_DIR"/*.yar; do
            if [ -f "$rule_file" ]; then
                local yara_result=$(yara -s "$rule_file" "$file" 2>/dev/null)
                if [ -n "$yara_result" ]; then
                    threat_score=$((threat_score + 30))
                    threat_reason="${threat_reason}YARA match: $(echo "$yara_result" | head -1); "
                fi
            fi
        done
    fi
    
    # Make decision based on threat score
    if [ $threat_score -ge $SEVERITY_THRESHOLD ]; then
        MALICIOUS_CACHE["$file"]="$hash"
        update_threat_intel "$file" "$hash" "$threat_score" "$threat_reason"
        return 0
    fi
    
    # If score is moderate, add to intel but don't take action
    if [ $threat_score -ge 40 ]; then
        update_threat_intel "$file" "$hash" "$threat_score" "$threat_reason"
    else
        CLEAN_CACHE["$file"]="$hash"
    fi
    
    return 1
}

# Handle suspicious cron file with advanced forensics
handle_suspicious_cron() {
    local file=$1
    local hash=$(sha256sum "$file" 2>/dev/null | cut -d' ' -f1)
    
    # Log the detection
    log_message "Suspicious cron file detected: $file (Hash: $hash)" "CRITICAL"
    
    # Create a directory for this sample
    local sample_dir="$SAMPLE_DIR/$hash"
    mkdir -p "$sample_dir" 2>/dev/null
    
    # Save a copy of the file for analysis
    if [ ! -f "$sample_dir/sample" ]; then
        cp "$file" "$sample_dir/sample" 2>/dev/null
        
        # Save metadata
        {
            echo "Path: $file"
            echo "Hash: $hash"
            echo "Detection time: $(date -Iseconds)"
            echo "File type: $(file -b "$file" 2>/dev/null)"
            echo "Permissions: $(stat -c %a "$file" 2>/dev/null)"
            echo "Owner: $(stat -c %U "$file" 2>/dev/null)"
            echo "Size: $(stat -c %s "$file" 2>/dev/null) bytes"
            echo "Content:"
            cat "$file" 2>/dev/null
        } > "$sample_dir/metadata.txt"
    fi
    
    # Check which crontab files reference this file
    for crontab in /etc/crontab /var/spool/cron/* /etc/cron.*/* /var/spool/anacron/*; do
        if [ -f "$crontab" ] && grep -q "$file" "$crontab" 2>/dev/null; then
            log_message "Found reference to suspicious cron file in $crontab" "CRITICAL"
            
            # Create a backup of the crontab
            cp "$crontab" "$sample_dir/$(basename "$crontab").backup" 2>/dev/null
            
            # Remove the reference safely
            local tmp_crontab=$(mktemp)
            grep -v "$file" "$crontab" > "$tmp_crontab" 2>/dev/null
            
            # Verify the new crontab is valid and not empty
            if [ -s "$tmp_crontab" ]; then
                cat "$tmp_crontab" > "$crontab" 2>/dev/null
                log_message "Removed reference to suspicious cron file from $crontab" "CRITICAL"
            else
                log_message "Warning: Could not safely remove cron reference (would result in empty file)" "CRITICAL"
            fi
            
            rm -f "$tmp_crontab"
        fi
    done
    
    # Check user crontabs
    for user_dir in /home/*; do
        local user=$(basename "$user_dir")
        if [ -f "/var/spool/cron/$user" ]; then
            if grep -q "$file" "/var/spool/cron/$user" 2>/dev/null; then
                log_message "Found reference to suspicious cron file in user crontab: $user" "CRITICAL"
                
                # Create a backup of the user crontab
                cp "/var/spool/cron/$user" "$sample_dir/crontab_${user}.backup" 2>/dev/null
                
                # Remove the reference safely
                local tmp_crontab=$(mktemp)
                grep -v "$file" "/var/spool/cron/$user" > "$tmp_crontab" 2>/dev/null
                
                # Verify the new crontab is valid and not empty
                if [ -s "$tmp_crontab" ]; then
                    cat "$tmp_crontab" > "/var/spool/cron/$user" 2>/dev/null
                    log_message "Removed reference to suspicious cron file from user crontab: $user" "CRITICAL"
                else
                    log_message "Warning: Could not safely remove cron reference for user $user (would result in empty file)" "CRITICAL"
                fi
                
                rm -f "$tmp_crontab"
            fi
        fi
    done
    
    # Check for running processes using this file
    if command -v fuser >/dev/null 2>&1; then
        local pids=$(fuser "$file" 2>/dev/null | tr -d ' ')
        if [ -n "$pids" ]; then
            log_message "Killing processes using suspicious cron file: $pids" "CRITICAL"
            kill -9 $pids 2>/dev/null
        fi
    fi
    
    # Remove the file
    if rm -f "$file" 2>/dev/null; then
        log_message "Successfully removed suspicious cron file: $file" "CRITICAL"
    else
        log_message "Failed to remove suspicious cron file: $file" "CRITICAL"
    fi
}

# Generate threat intelligence report
generate_threat_report() {
    if [ -f "$INTEL_DB" ] && command -v jq >/dev/null 2>&1; then
        local threat_count=$(jq '.threats | length' "$INTEL_DB" 2>/dev/null)
        local high_threats=$(jq '.threats | to_entries[] | select(.value.score >= 80) | .key' "$INTEL_DB" 2>/dev/null | wc -l)
        
        log_message "Suspicious Cron Threat Report: Total threats=$threat_count, High severity threats=$high_threats" "CRITICAL"
        
        # List top threats
        local top_threats=$(jq -r '.threats | to_entries | sort_by(.value.score) | reverse | .[0:5] | .[] | "\(.key):\(.value.score):\(.value.reason)"' "$INTEL_DB" 2>/dev/null)
        if [ -n "$top_threats" ]; then
            log_message "Top suspicious cron threats:" "CRITICAL"
            while IFS=: read -r hash score reason; do
                log_message "  Hash=$hash, Score=$score, Reason=$reason" "CRITICAL"
            done <<< "$top_threats"
        fi
    fi
}

# Scan directories for suspicious cron files
scan_directories() {
    local dir=$1
    local expanded_dir=${dir/\~/$HOME}
    
    # Skip if directory doesn't exist
    if [ ! -d "$expanded_dir" ]; then
        return
    fi
    
    # Build cron pattern for find command
    local cron_pattern=""
    for pattern in "${CRON_PATTERNS[@]}"; do
        if [ -z "$cron_pattern" ]; then
            cron_pattern="-regex \".*${pattern}\""
        else
            cron_pattern="${cron_pattern} -o -regex \".*${pattern}\""
        fi
    done
    
    # Find suspicious files - optimized to use a single find command
    local files=$(eval "find \"$expanded_dir\" -type f \\( $cron_pattern -o -executable \\) -size -1M 2>/dev/null")
    
    # Process each file
    local count=0
    while read -r file; do
        if [ -n "$file" ] && [ -f "$file" ]; then
            if is_suspicious_cron "$file"; then
                handle_suspicious_cron "$file"
                count=$((count + 1))
            fi
        fi
    done <<< "$files"
    
    # Return the count of suspicious files found
    echo $count
}

# Check system crontab files for suspicious entries
check_system_crontabs() {
    local crontabs=("/etc/crontab" "/etc/anacrontab")
    
    # Add all files in cron directories
    for cron_dir in /etc/cron.d /etc/cron.hourly /etc/cron.daily /etc/cron.weekly /etc/cron.monthly; do
        if [ -d "$cron_dir" ]; then
            for file in "$cron_dir"/*; do
                if [ -f "$file" ]; then
                    crontabs+=("$file")
                fi
            done
        fi
    done
    
    # Add user crontabs
    for user_crontab in /var/spool/cron/*; do
        if [ -f "$user_crontab" ]; then
            crontabs+=("$user_crontab")
        fi
    done
    
    # Check each crontab file
    local count=0
    for crontab in "${crontabs[@]}"; do
        if [ -f "$crontab" ] && is_suspicious_cron "$crontab"; then
            handle_suspicious_cron "$crontab"
            count=$((count + 1))
        fi
    done
    
    # Return the count of suspicious crontabs found
    echo $count
}

# Main function - enhanced with advanced detection
main() {
    log_message "Suspicious Cron Dropper Killer (Optimized) started" "CRITICAL"
    
    # Set process limits for resource management
    renice 15 $$ > /dev/null 2>&1  # Lower priority
    ionice -c 3 -p $$ > /dev/null 2>&1  # Idle I/O priority
    
    # Initialize performance monitoring
    local start_time=$(date +%s)
    local scan_count=0
    local concurrent_jobs=0
    ionice -c3 -p $$ > /dev/null 2>&1
    
    # Create default YARA rules
    create_default_yara_rules
    
    # Load cache
    load_cache
    
    # Counter for maintenance operations
    local counter=0
    local report_interval=24  # Generate report every 24 cycles
    
    while true; do
        local cycle_start=$(date +%s)
        local total_suspicious=0
        scan_count=$((scan_count + 1))
        
        # Performance management
        manage_performance_cache
        
        # Limit concurrent operations
        if [ $concurrent_jobs -ge $MAX_CONCURRENT_SCANS ]; then
            wait  # Wait for background jobs to complete
            concurrent_jobs=0
        fi
        
        # Check system crontab files first (high priority)
        {
            local count=$(check_system_crontabs)
            total_suspicious=$((total_suspicious + count))
        } &
        concurrent_jobs=$((concurrent_jobs + 1))
        
        # Scan suspicious directories with limited concurrency
        local dir_count=0
        for dir in "${SUSPICIOUS_DIRS[@]}"; do
            if [ $concurrent_jobs -ge $MAX_CONCURRENT_SCANS ]; then
                wait  # Wait for some jobs to complete
                concurrent_jobs=0
            fi
            
            {
                local count=$(scan_directories "$dir")
                echo "$count" > "/tmp/scan_result_$$_$dir_count"
            } &
            concurrent_jobs=$((concurrent_jobs + 1))
            dir_count=$((dir_count + 1))
        done
        
        # Wait for all background scans to complete
        wait
        concurrent_jobs=0
        
        # Collect results from background scans
        for ((i=0; i<dir_count; i++)); do
            if [ -f "/tmp/scan_result_$$_$i" ]; then
                local count=$(cat "/tmp/scan_result_$$_$i")
                total_suspicious=$((total_suspicious + count))
                rm -f "/tmp/scan_result_$$_$i"
            fi
        done
        
        # Update performance counters
        PERF_COUNTERS["scans_completed"]=$((${PERF_COUNTERS["scans_completed"]} + 1))
        if [ $total_suspicious -gt 0 ]; then
            PERF_COUNTERS["threats_detected"]=$((${PERF_COUNTERS["threats_detected"]} + total_suspicious))
            log_message "Scan #$scan_count: Found and eliminated $total_suspicious suspicious cron files" "CRITICAL"
        fi
        
        # Increment counter and perform maintenance periodically
        counter=$((counter + 1))
        
        # Optimized maintenance schedule
        if [ $((counter % 5)) -eq 0 ]; then
            save_cache &  # Save cache in background
        fi
        
        if [ $((counter % 20)) -eq 0 ]; then
            generate_threat_report &  # Generate report in background
        fi
        
        # Adaptive sleep based on system load and findings
        local cycle_time=$(($(date +%s) - cycle_start))
        local sleep_time=$SCAN_INTERVAL
        
        if [ $total_suspicious -gt 0 ]; then
            sleep_time=30  # Faster scanning when threats found
        elif [ $cycle_time -gt 30 ]; then
            sleep_time=$((SCAN_INTERVAL + 30))  # Slower if system is loaded
        fi
        
        # Log performance every 50 scans
        if [ $((scan_count % 50)) -eq 0 ]; then
            local runtime=$(($(date +%s) - start_time))
            log_message "Performance: $scan_count scans in ${runtime}s, ${PERF_COUNTERS["cache_hits"]} cache hits" "INFO"
        fi
        
        sleep $sleep_time
    done
}

# Trap signals for clean exit and reporting
trap "save_cache; generate_threat_report; log_message 'Suspicious Cron Dropper Killer Hardened Fangbull stopped' 'CRITICAL'; exit 0" SIGTERM SIGINT

main 