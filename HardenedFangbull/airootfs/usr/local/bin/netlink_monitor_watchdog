#!/bin/bash

# Netlink Monitor Watchdog - Hardened Fangbull
# Advanced monitoring of netlink sockets with memory-safe operations

LOG_FILE="/var/log/fangbull-ids/netlink_monitor.log"
LOG_MAX_SIZE=5242880  # 5MB max log size
BASELINE_FILE="/var/log/fangbull-ids/netlink_baseline.json"
MAX_PROCESSES_PER_SCAN=500  # Maximum processes to check per scan
MAX_BUFFER_SIZE=16384       # Maximum buffer size for commands (16KB)
MAX_NETLINK_CACHE=1000      # Maximum entries in netlink process cache
MAX_ROUTE_ENTRIES=1000      # Maximum route entries to store

# Create log directory with secure permissions
mkdir -p "$(dirname "$LOG_FILE")" 2>/dev/null
chmod 750 "$(dirname "$LOG_FILE")" 2>/dev/null

# Rotate log if it exceeds max size with atomic operations
rotate_log() {
    if [ -f "$LOG_FILE" ] && [ $(stat -c%s "$LOG_FILE" 2>/dev/null || echo 0) -gt $LOG_MAX_SIZE ]; then
        local timestamp=$(date +%Y%m%d%H%M%S)
        local backup_file="$LOG_FILE.$timestamp"
        
        # Use temporary file for atomic operations
        cp "$LOG_FILE" "$LOG_FILE.tmp" 2>/dev/null
        mv "$LOG_FILE.tmp" "$backup_file" 2>/dev/null
        
        # Compress with size limit check
        if [ -f "$backup_file" ] && [ $(stat -c%s "$backup_file" 2>/dev/null || echo 0) -lt $((LOG_MAX_SIZE*2)) ]; then
            gzip -f "$backup_file" 2>/dev/null
        fi
        
        # Truncate original log file safely
        : > "$LOG_FILE"
        chmod 640 "$LOG_FILE" 2>/dev/null
    fi
}

# Memory-safe logging function
log_message() {
    # Only log critical events
    if [ "$2" = "CRITICAL" ]; then
        local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
        local message="${1:0:1024}"  # Truncate message to prevent buffer overflow
        echo "[$timestamp] $message" >> "$LOG_FILE"
        rotate_log
    fi
}

# Store baseline network configuration - optimized data structures
declare -A baseline_interfaces
declare -A baseline_routes
declare -A legitimate_changes
declare -A netlink_processes

# Load baseline if it exists
load_baseline() {
    if [ -f "$BASELINE_FILE" ]; then
        # Load interfaces
        while IFS=':' read -r iface data; do
            if [[ "$iface" == "INTERFACE"* ]]; then
                local interface=${iface#INTERFACE:}
                baseline_interfaces["$interface"]="$data"
            elif [[ "$iface" == "ROUTE"* ]]; then
                local route=${iface#ROUTE:}
                baseline_routes["$route"]="$data"
            fi
        done < "$BASELINE_FILE"
    fi
}

# Save baseline with memory safety checks
save_baseline() {
    # Create temp file first to avoid race conditions
    local tmp_file=$(mktemp)
    if [ -z "$tmp_file" ] || [ ! -w "$tmp_file" ]; then
        log_message "Failed to create temporary file for baseline update" "CRITICAL"
        return 1
    fi
    
    # Save interfaces with limits
    local count=0
    for iface in "${!baseline_interfaces[@]}"; do
        if [ $count -lt $MAX_NETLINK_CACHE ]; then
            # Truncate values to prevent buffer overflow
            local safe_iface="${iface:0:64}"
            local safe_data="${baseline_interfaces[$iface]:0:256}"
            echo "INTERFACE:$safe_iface:$safe_data" >> "$tmp_file"
            count=$((count + 1))
        fi
    done
    
    # Save routes with limits
    count=0
    for route in "${!baseline_routes[@]}"; do
        if [ $count -lt $MAX_ROUTE_ENTRIES ]; then
            # Truncate values to prevent buffer overflow
            local safe_route="${route:0:64}"
            local safe_data="${baseline_routes[$route]:0:512}"
            echo "ROUTE:$safe_route:$safe_data" >> "$tmp_file"
            count=$((count + 1))
        fi
    done
    
    # Atomic update with size check
    if [ -s "$tmp_file" ] && [ $(stat -c%s "$tmp_file" 2>/dev/null || echo 0) -lt 1048576 ]; then
        mv "$tmp_file" "$BASELINE_FILE" 2>/dev/null
        chmod 640 "$BASELINE_FILE" 2>/dev/null
    else
        log_message "Baseline file too large or empty, not updating" "CRITICAL"
        rm -f "$tmp_file"
    fi
}

# Capture baseline network configuration with memory safety
capture_baseline() {
    log_message "Capturing baseline network configuration" "CRITICAL"
    
    # Clear existing baseline
    baseline_interfaces=()
    baseline_routes=()
    
    # Capture interface information with timeout and limits
    local count=0
    while read -r line && [ $count -lt $MAX_NETLINK_CACHE ]; do
        # Truncate line to prevent buffer overflow
        line="${line:0:$MAX_BUFFER_SIZE}"
        
        if [[ "$line" =~ ^[0-9]+:\ ([^:]+): ]]; then
            local interface="${BASH_REMATCH[1]}"
            # Truncate interface name to prevent buffer overflow
            interface="${interface:0:32}"
            
            # Store only essential information with timeout
            local state=$(timeout 2s bash -c "echo \"$line\" | grep -o \"state [A-Z]*\" | cut -d' ' -f2" 2>/dev/null)
            local mac=$(timeout 2s ip link show dev "$interface" 2>/dev/null | grep -o "link/[^ ]*" | cut -d'/' -f2)
            
            # Truncate values to prevent buffer overflow
            state="${state:0:20}"
            mac="${mac:0:20}"
            
            baseline_interfaces["$interface"]="$state:$mac"
            count=$((count + 1))
        fi
    done < <(timeout 10s ip -br link show)
    
    # Capture routing information with limits
    count=0
    while read -r line && [ $count -lt $MAX_ROUTE_ENTRIES ]; do
        # Truncate line to prevent buffer overflow
        line="${line:0:$MAX_BUFFER_SIZE}"
        
        # Generate hash with timeout
        local hash=$(echo "$line" | md5sum | cut -d' ' -f1)
        if [ -n "$hash" ]; then
            baseline_routes["$hash"]="${line:0:512}"  # Truncate route info
            count=$((count + 1))
        fi
    done < <(timeout 10s ip -br route show | grep -v "^default" | head -n $MAX_ROUTE_ENTRIES)
    
    # Also store default route separately with timeout
    local default_route=$(timeout 5s ip -br route show | grep "^default" | head -n 1)
    if [ -n "$default_route" ]; then
        baseline_routes["default"]="${default_route:0:512}"  # Truncate route info
    fi
    
    # Log baseline statistics
    log_message "Baseline captured: ${#baseline_interfaces[@]} interfaces, ${#baseline_routes[@]} routes" "CRITICAL"
    
    # Save baseline to file
    save_baseline
}

# Check for suspicious netlink activity with memory safety
check_netlink_activity() {
    # Check for processes with netlink sockets
    local suspicious_count=0
    local details=""
    local process_count=0
    
    # Look for processes with netlink sockets with timeout and output limit
    while read -r line && [ "$process_count" -lt "$MAX_PROCESSES_PER_SCAN" ]; do
        # Truncate line to prevent buffer overflow
        line="${line:0:$MAX_BUFFER_SIZE}"
        
        if [[ "$line" == *"netlink"* ]]; then
            # Extract PID safely using absolute paths
            local pid=$(/bin/echo "$line" | /bin/grep -o "pid=[0-9]*" | /usr/bin/cut -d'=' -f2)
            
            # Skip if no PID found or invalid format
            if [ -z "$pid" ] || ! [[ "$pid" =~ ^[0-9]+$ ]]; then
                continue
            fi
            
            # Get program name with timeout to prevent hanging (using absolute paths)
            local program=$(/usr/bin/timeout 2s /bin/ps -o comm= -p "$pid" 2>/dev/null)
            
            # Skip if process no longer exists
            if [ -z "$program" ] || [ ! -d "/proc/$pid" ]; then
                continue
            }
            
            process_count=$((process_count + 1))
            
            # Skip system processes that legitimately use netlink
            local legitimate_programs=(
                "NetworkManager" "systemd-networkd" "dhclient" "wpa_supplicant"
                "systemd-resolved" "avahi-daemon" "dnsmasq" "systemd" "polkitd"
                "networkd" "connmand" "nm-dispatcher" "ip" "route" "pacman" "pamac"
                "systemd-udevd" "udevd" "iwd" "bluez" "bluetoothd"
            )
            
            local is_legitimate=0
            for legit in "${legitimate_programs[@]}"; do
                if [[ "$program" == "$legit"* ]]; then
                    is_legitimate=1
                    break
                fi
            done
            
            # Skip legitimate programs
            if [ $is_legitimate -eq 1 ]; then
                continue
            fi
            
            # Check if this is a root process (non-root processes with netlink are suspicious)
            local user=$(ps -o user= -p "$pid" 2>/dev/null | tr -d ' ')
            if [[ "$user" != "root" ]]; then
                suspicious_count=$((suspicious_count + 1))
                details="${details}Non-root process with netlink: PID=$pid, User=$user, Program=$program; "
                
                # Store in netlink_processes for tracking
                netlink_processes["$pid"]="$program:$user"
            fi
            
            # Check if the process is unknown or has suspicious attributes
            if ! command -v "$program" &>/dev/null; then
                suspicious_count=$((suspicious_count + 1))
                details="${details}Unknown program with netlink: PID=$pid, Program=$program; "
                
                # Store in netlink_processes for tracking
                netlink_processes["$pid"]="$program:$user"
            fi
        fi
    done < <(ss -p | grep netlink)
    
    # Check for network configuration changes - more efficient approach
    
    # Check interface changes
    while read -r line; do
        if [[ "$line" =~ ^[0-9]+:\ ([^:]+): ]]; then
            local interface="${BASH_REMATCH[1]}"
            
            # Skip if this is a new legitimate interface
            if [[ -n "${legitimate_changes["interface:$interface"]}" ]]; then
                continue
            fi
            
            # Skip loopback and virtual interfaces
            if [[ "$interface" == "lo" ]] || [[ "$interface" == "veth"* ]] || 
               [[ "$interface" == "docker"* ]] || [[ "$interface" == "br-"* ]]; then
                continue
            fi
            
            # Get essential info with direct commands instead of bash -c
            # Create a temporary file for the line to avoid command injection
            local tmp_line_file=$(mktemp)
            if [ -n "$tmp_line_file" ] && [ -w "$tmp_line_file" ]; then
                echo "${line:0:$MAX_BUFFER_SIZE}" > "$tmp_line_file"
                local state=$(/usr/bin/timeout 2s /bin/sh -c "/bin/cat \"$tmp_line_file\" | /bin/grep -o \"state [A-Z]*\" | /usr/bin/cut -d' ' -f2" 2>/dev/null)
                /bin/rm -f "$tmp_line_file"
            fi
            
            # Get MAC address with direct command
            local mac=$(/usr/bin/timeout 2s /bin/sh -c "/sbin/ip link show dev \"$interface\" 2>/dev/null | /bin/grep -o \"link/[^ ]*\" | /usr/bin/cut -d'/' -f2" 2>/dev/null)
            
            # Truncate values to prevent buffer overflow
            state="${state:0:20}"
            mac="${mac:0:20}"
            local current_info="$state:$mac"
            
            # Check if interface exists in baseline
            if [[ -z "${baseline_interfaces["$interface"]}" ]]; then
                suspicious_count=$((suspicious_count + 1))
                details="${details}New interface detected: ${interface:0:32}; "
            elif [[ "${baseline_interfaces["$interface"]}" != "$current_info" ]]; then
                # Interface configuration changed
                suspicious_count=$((suspicious_count + 1))
                details="${details}Interface configuration changed: ${interface:0:32}; "
            fi
        fi
    done < <(ip -br link show)
    
    # Check routing table changes - focus on default route
    local current_default=$(ip -br route show | grep "^default")
    if [[ -n "${baseline_routes["default"]}" && "$current_default" != "${baseline_routes["default"]}" ]]; then
        suspicious_count=$((suspicious_count + 2))  # Higher weight for default route changes
        details="${details}Default route modified; "
    fi
    
    # Return result
    if [ "$suspicious_count" -gt 0 ]; then
        echo "$details"
        return 0
    fi
    
    return 1
}

# Handle suspicious netlink activity with memory safety
handle_suspicious_activity() {
    local details="${1:0:1024}"  # Truncate to prevent buffer overflow
    
    log_message "Suspicious netlink activity detected: $details" "CRITICAL"
    
    # Take action on suspicious processes with limits
    local process_count=0
    local terminated_count=0
    
    for pid in "${!netlink_processes[@]}"; do
        # Apply process limit per scan
        if [ "$process_count" -ge 50 ]; then
            log_message "Process handling limit reached (50), continuing in next cycle" "CRITICAL"
            break
        fi
        
        # Validate PID format
        if ! [[ "$pid" =~ ^[0-9]+$ ]]; then
            unset netlink_processes["$pid"]
            continue
        }
        
        # Check if process still exists
        if [ -d "/proc/$pid" ]; then
            # Extract info with safety checks
            local info="${netlink_processes["$pid"]:0:256}"
            local program="${info%%:*}"
            local user="${info#*:}"
            
            # Truncate values to prevent buffer overflow
            program="${program:0:64}"
            user="${user:0:32}"
            
            # Only kill non-root suspicious processes to avoid system damage
            if [ "$user" != "root" ]; then
                log_message "Terminating suspicious netlink process: PID=$pid, Program=$program, User=$user" "CRITICAL"
                timeout 5s kill -9 "$pid" 2>/dev/null
                terminated_count=$((terminated_count + 1))
            else
                log_message "Warning: Root-owned suspicious netlink process: PID=$pid, Program=$program" "CRITICAL"
            fi
        fi
        
        # Remove from tracking
        unset netlink_processes["$pid"]
        process_count=$((process_count + 1))
    done
    
    # Report summary
    if [ "$terminated_count" -gt 0 ]; then
        log_message "Summary: Terminated $terminated_count suspicious netlink processes" "CRITICAL"
    fi
}

# Register a legitimate network change with memory safety
register_legitimate_change() {
    local type="${1:0:32}"  # Truncate to prevent buffer overflow
    local name="${2:0:64}"  # Truncate to prevent buffer overflow
    
    # Validate inputs
    if [ -z "$type" ] || [ -z "$name" ]; then
        return 1
    fi
    
    # Store with size limit check
    if [ ${#legitimate_changes[@]} -lt $MAX_NETLINK_CACHE ]; then
        legitimate_changes["$type:$name"]=$(date +%s)
    else
        # If cache is full, remove oldest entry
        local oldest_key=""
        local oldest_time=9999999999
        
        for key in "${!legitimate_changes[@]}"; do
            local change_time=${legitimate_changes["$key"]}
            if [ "$change_time" -lt "$oldest_time" ]; then
                oldest_time=$change_time
                oldest_key=$key
            fi
        done
        
        # Remove oldest and add new
        if [ -n "$oldest_key" ]; then
            unset legitimate_changes["$oldest_key"]
            legitimate_changes["$type:$name"]=$(date +%s)
        fi
    fi
    
    # Expire old legitimate changes after 5 minutes
    local current_time=$(date +%s)
    local expired=()
    local count=0
    
    for key in "${!legitimate_changes[@]}"; do
        # Limit the number of items processed to prevent excessive CPU usage
        if [ $count -ge 100 ]; then
            break
        fi
        
        local change_time=${legitimate_changes["$key"]}
        if (( current_time - change_time > 300 )); then
            expired+=("$key")
        fi
        count=$((count + 1))
    done
    
    # Remove expired entries
    for key in "${expired[@]}"; do
        unset legitimate_changes["$key"]
    done
}

# Main function - enhanced with memory safety
main() {
    log_message "Netlink Monitor Watchdog Hardened Fangbull started" "CRITICAL"
    
    # Use lower CPU priority and IO priority
    renice 10 $$ > /dev/null 2>&1
    ionice -c3 -p $$ > /dev/null 2>&1
    
    # Set resource limits to prevent memory bloat
    ulimit -v 104857600 2>/dev/null  # Virtual memory limit: 100MB
    ulimit -t 3600 2>/dev/null       # CPU time limit: 1 hour
    
    # Load or capture baseline network configuration
    load_baseline
    if [ ${#baseline_interfaces[@]} -eq 0 ] || [ ${#baseline_routes[@]} -eq 0 ]; then
        capture_baseline
    fi
    
    # Counter for maintenance operations with overflow protection
    local counter=0
    
    # Main monitoring loop
    while true; do
        # Check for suspicious netlink activity directly without using bash -c
        local suspicious_activity=""
        local exit_status=1
        
        # Run check_netlink_activity directly without bash -c
        # Create a wrapper function for timeout to use
        check_netlink_wrapper() {
            check_netlink_activity
        }
        
        # Export the function so timeout can access it
        export -f check_netlink_activity
        export -f check_netlink_wrapper
        
        # Use timeout with direct function call
        if suspicious_activity=$(/usr/bin/timeout --foreground 30s /bin/sh -c "check_netlink_wrapper" 2>/dev/null); then
            exit_status=0
        fi
        
        # Unset exported functions to prevent namespace pollution
        unset -f check_netlink_wrapper
        
        if [ $exit_status -eq 0 ] && [ -n "$suspicious_activity" ]; then
            handle_suspicious_activity "${suspicious_activity:0:$MAX_BUFFER_SIZE}"
        fi
        
        # Increment counter with overflow protection and perform maintenance periodically
        counter=$((counter % 1000000 + 1))
        if [ $counter -eq 24 ]; then  # Recapture baseline every ~24 hours
            capture_baseline
        fi
        
        # Enhanced memory management with progressive cleanup and optimized algorithms
        if [ $((counter % 20)) -eq 0 ]; then  # More frequent checks (every 20 cycles)
            # Check memory usage with accurate method
            local mem_usage=$(/bin/ps -o rss= -p $$ 2>/dev/null || echo 0)
            local mem_threshold_low=25600    # 25MB low threshold
            local mem_threshold_med=40960    # 40MB medium threshold
            local mem_threshold_high=51200   # 50MB high threshold
            
            # Level 1: Basic cleanup (always perform)
            # Clean up processes that no longer exist - more efficient approach
            if [ ${#netlink_processes[@]} -gt 0 ]; then
                local pids_to_remove=()
                
                # Use a single pass through /proc to check all PIDs at once
                local existing_pids=$(/bin/ls -d /proc/[0-9]* 2>/dev/null | /bin/sed 's|/proc/||')
                
                # Create a lookup hash for fast existence check
                declare -A pid_exists
                for pid in $existing_pids; do
                    pid_exists["$pid"]=1
                done
                
                # Check which processes no longer exist
                for key in "${!netlink_processes[@]}"; do
                    if ! [[ "$key" =~ ^[0-9]+$ ]] || [ -z "${pid_exists[$key]}" ]; then
                        pids_to_remove+=("$key")
                    fi
                done
                
                # Remove non-existent processes
                for key in "${pids_to_remove[@]}"; do
                    unset netlink_processes["$key"]
                done
                
                # Clean up temporary data
                unset pid_exists
                unset pids_to_remove
                unset existing_pids
            fi
            
            # Level 2: Medium cleanup (for medium memory usage)
            if [ "$mem_usage" -gt "$mem_threshold_low" ]; then
                log_message "Medium memory usage detected: $((mem_usage/1024)) MB, performing standard cleanup" "CRITICAL"
                
                # Clean up legitimate_changes with batch processing
                if [ ${#legitimate_changes[@]} -gt 50 ]; then
                    local current_time=$(/bin/date +%s)
                    local cutoff_time=$((current_time - 180))  # 3 minutes
                    local keys_to_remove=()
                    local batch_size=0
                    local max_batch=100
                    
                    # Collect keys in batches for efficient removal
                    for key in "${!legitimate_changes[@]}"; do
                        if [ $batch_size -ge $max_batch ]; then
                            break
                        fi
                        
                        local change_time=${legitimate_changes["$key"]}
                        if [ "$change_time" -lt "$cutoff_time" ]; then
                            keys_to_remove+=("$key")
                            batch_size=$((batch_size + 1))
                        fi
                    done
                    
                    # Remove collected keys in one go
                    if [ ${#keys_to_remove[@]} -gt 0 ]; then
                        log_message "Cleaning up ${#keys_to_remove[@]} expired legitimate changes" "CRITICAL"
                        for key in "${keys_to_remove[@]}"; do
                            unset legitimate_changes["$key"]
                        done
                    fi
                    
                    # Clean up
                    unset keys_to_remove
                    unset batch_size
                    unset max_batch
                    unset cutoff_time
                    unset current_time
                fi
                
                # Force some garbage collection
                unset suspicious_activity
            fi
            
            # Level 3: Aggressive cleanup (for high memory usage)
            if [ "$mem_usage" -gt "$mem_threshold_med" ]; then
                log_message "High memory usage detected: $((mem_usage/1024)) MB, performing deep cleanup" "CRITICAL"
                
                # Trim baseline data if too large - more efficient approach
                if [ ${#baseline_routes[@]} -gt $((MAX_ROUTE_ENTRIES/2)) ]; then
                    log_message "Trimming route baseline data (${#baseline_routes[@]} entries)" "CRITICAL"
                    
                    # Calculate how many entries to keep
                    local keep_count=$((MAX_ROUTE_ENTRIES/2))
                    local current_count=${#baseline_routes[@]}
                    local remove_count=$((current_count - keep_count))
                    
                    if [ $remove_count -gt 0 ]; then
                        # Save default route
                        local default_route="${baseline_routes["default"]}"
                        
                        # Get all keys except default
                        local keys_to_consider=()
                        for key in "${!baseline_routes[@]}"; do
                            if [ "$key" != "default" ]; then
                                keys_to_consider+=("$key")
                            fi
                        done
                        
                        # Shuffle keys to avoid biased removal
                        local shuffled_keys=()
                        while [ ${#keys_to_consider[@]} -gt 0 ] && [ ${#shuffled_keys[@]} -lt $remove_count ]; do
                            # Select a random index
                            local idx=$(( RANDOM % ${#keys_to_consider[@]} ))
                            shuffled_keys+=("${keys_to_consider[$idx]}")
                            # Remove the selected key from consideration
                            unset "keys_to_consider[$idx]"
                            # Re-index the array
                            keys_to_consider=("${keys_to_consider[@]}")
                        done
                        
                        # Remove the selected keys
                        for key in "${shuffled_keys[@]}"; do
                            unset baseline_routes["$key"]
                        done
                        
                        # Clean up
                        unset shuffled_keys
                        unset keys_to_consider
                        
                        # Save trimmed baseline
                        save_baseline
                    fi
                    
                    # Clean up variables
                    unset keep_count
                    unset current_count
                    unset remove_count
                fi
            fi
            
            # Level 4: Critical cleanup (for very high memory usage)
            if [ "$mem_usage" -gt "$mem_threshold_high" ]; then
                log_message "CRITICAL: Very high memory usage detected: $((mem_usage/1024)) MB, performing emergency cleanup" "CRITICAL"
                
                # Reset all non-essential arrays
                log_message "Performing emergency reset of baseline data" "CRITICAL"
                
                # Save default route
                local default_route="${baseline_routes["default"]}"
                
                # Reset arrays
                baseline_interfaces=()
                baseline_routes=()
                
                # Restore default route
                if [ -n "$default_route" ]; then
                    baseline_routes["default"]="$default_route"
                fi
                
                # Recapture minimal baseline
                capture_baseline
                
                # Force aggressive garbage collection
                unset suspicious_activity
                unset mem_threshold_high
                unset mem_threshold_med
                unset mem_threshold_low
                
                # Request garbage collection from system
                sleep 0.1
            fi
            
            # Final cleanup
            unset mem_usage
        fi
        
        # Sleep to reduce system load
        sleep 60
    done
}

# Trap signals for clean exit and reporting
trap "save_baseline; log_message 'Netlink Monitor Watchdog Hardened Fangbull stopped' 'CRITICAL'; exit 0" SIGTERM SIGINT SIGHUP

main 