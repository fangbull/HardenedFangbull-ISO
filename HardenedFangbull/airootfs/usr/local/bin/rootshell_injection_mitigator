#!/bin/bash

# Rootshell Injection Mitigator - Hardened Fangbull
# Advanced detection and prevention of shell binary modifications and rootkit injections

# Configuration
LOG_FILE="/var/log/fangbull-ids/rootshell_mitigator.log"
LOG_MAX_SIZE=5242880  # 5MB max log size
BASELINE_FILE="/var/log/fangbull-ids/rootshell_baseline.db"
FORENSIC_DIR="/var/log/fangbull-ids/rootshell_forensics"
SAMPLE_DIR="/var/log/fangbull-ids/rootshell_samples"
INTEL_DB="/var/log/fangbull-ids/rootshell_intel.db"
SCAN_INTERVAL=45      # Seconds between scans
BASELINE_REFRESH=86400 # Seconds between baseline refreshes (24 hours)
SEVERITY_THRESHOLD=70 # Severity score threshold for action

# Create required directories
mkdir -p "$(dirname "$LOG_FILE")" 2>/dev/null
mkdir -p "$FORENSIC_DIR" 2>/dev/null
mkdir -p "$SAMPLE_DIR" 2>/dev/null

# Rotate log if it exceeds max size
rotate_log() {
    if [ -f "$LOG_FILE" ] && [ $(stat -c%s "$LOG_FILE" 2>/dev/null || echo 0) -gt $LOG_MAX_SIZE ]; then
        local timestamp=$(date +%Y%m%d%H%M%S)
        mv "$LOG_FILE" "$LOG_FILE.$timestamp" 2>/dev/null
        gzip -f "$LOG_FILE.$timestamp" 2>/dev/null
    fi
}

log_message() {
    # Only log critical events
    if [ "$2" = "CRITICAL" ]; then
        local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
        echo "[$timestamp] $1" >> "$LOG_FILE"
        rotate_log
    fi
}

# Shell binaries to monitor - comprehensive list
SHELL_BINARIES=(
    "/bin/bash"
    "/bin/sh"
    "/bin/dash"
    "/bin/zsh"
    "/bin/ksh"
    "/bin/csh"
    "/bin/tcsh"
    "/usr/bin/bash"
    "/usr/bin/sh"
    "/usr/bin/dash"
    "/usr/bin/zsh"
    "/usr/bin/ksh"
    "/usr/bin/csh"
    "/usr/bin/tcsh"
    "/usr/local/bin/bash"
    "/usr/local/bin/sh"
    "/usr/local/bin/zsh"
)

# System binaries to monitor - comprehensive list
SYSTEM_BINARIES=(
    "/bin/ls"
    "/bin/ps"
    "/bin/netstat"
    "/bin/ip"
    "/bin/ss"
    "/bin/find"
    "/bin/grep"
    "/bin/awk"
    "/bin/sed"
    "/bin/cat"
    "/bin/cp"
    "/bin/mv"
    "/bin/rm"
    "/bin/chmod"
    "/bin/chown"
    "/bin/su"
    "/bin/sudo"
    "/usr/bin/who"
    "/usr/bin/whoami"
    "/usr/bin/id"
    "/usr/bin/top"
    "/usr/bin/htop"
    "/usr/bin/lsof"
    "/usr/bin/pstree"
    "/usr/bin/pkill"
    "/usr/bin/killall"
    "/usr/bin/crontab"
    "/usr/bin/passwd"
    "/usr/bin/systemctl"
    "/usr/bin/journalctl"
    "/usr/bin/ssh"
    "/usr/bin/scp"
    "/usr/bin/sftp"
    "/usr/bin/curl"
    "/usr/bin/wget"
)

# Advanced data structures for binary tracking
declare -A baseline_hashes      # Baseline hashes for binaries
declare -A checked_binaries     # Binaries we've already checked this run
declare -A modified_binaries    # Binaries already detected as modified
declare -A binary_processes     # Map binaries to processes using them
declare -A process_cmd_cache    # Cache for process commands
declare -A process_user_cache   # Cache for process users

# Load baseline if it exists
load_baseline() {
    if [ -f "$BASELINE_FILE" ]; then
        while IFS=: read -r type data; do
            if [ "$type" = "BASELINE" ]; then
                IFS='|' read -r path hash <<< "$data"
                baseline_hashes["$path"]="$hash"
            elif [ "$type" = "MODIFIED" ]; then
                modified_binaries["$data"]=1
            fi
        done < "$BASELINE_FILE"
    fi
}

# Save baseline periodically
save_baseline() {
    # Create temp file first to avoid race conditions
    local tmp_file=$(mktemp)
    
    # Save baseline hashes
    for path in "${!baseline_hashes[@]}"; do
        echo "BASELINE:$path|${baseline_hashes[$path]}" >> "$tmp_file"
    done
    
    # Save modified binaries
    for path in "${!modified_binaries[@]}"; do
        echo "MODIFIED:$path" >> "$tmp_file"
    done
    
    # Atomic update
    mv "$tmp_file" "$BASELINE_FILE" 2>/dev/null
}

# Update threat intelligence database
update_threat_intel() {
    local binary=$1
    local hash=$2
    local original_hash=$3
    local severity=$4
    local details=$5
    local timestamp=$(date -Iseconds)
    
    # Create temp file for atomic write
    local tmp_file=$(mktemp)
    
    # Use jq if available for proper JSON handling
    if command -v jq >/dev/null 2>&1; then
        if [ -f "$INTEL_DB" ]; then
            jq --arg binary "$binary" \
               --arg hash "$hash" \
               --arg orig_hash "$original_hash" \
               --arg severity "$severity" \
               --arg details "$details" \
               --arg time "$timestamp" \
            '.threats[$binary] = {
                "current_hash": $hash,
                "original_hash": $orig_hash,
                "severity": ($severity|tonumber),
                "details": $details,
                "timestamp": $time
             } | .metadata.last_update = $time' \
            "$INTEL_DB" > "$tmp_file" 2>/dev/null
        else
            echo "{\"threats\":{\"$binary\":{\"current_hash\":\"$hash\",\"original_hash\":\"$original_hash\",\"severity\":$severity,\"details\":\"$details\",\"timestamp\":\"$timestamp\"}},\"metadata\":{\"last_update\":\"$timestamp\"}}" > "$tmp_file"
        fi
    else
        # Simple fallback if jq not available
        echo "{\"threats\":{\"$binary\":{\"current_hash\":\"$hash\",\"original_hash\":\"$original_hash\",\"severity\":$severity,\"details\":\"$details\",\"timestamp\":\"$timestamp\"}},\"metadata\":{\"last_update\":\"$timestamp\"}}" > "$tmp_file"
    fi
    
    # Atomic update
    if [ -s "$tmp_file" ]; then
        mv "$tmp_file" "$INTEL_DB"
    else
        rm -f "$tmp_file"
    fi
}

# Get command line for a process
get_process_cmd() {
    local pid=$1
    
    # Check cache first
    if [ -n "${process_cmd_cache[$pid]}" ]; then
        echo "${process_cmd_cache[$pid]}"
        return
    fi
    
    # Get command and cache it
    local cmd=$(ps -o comm= -p "$pid" 2>/dev/null)
    if [ -n "$cmd" ]; then
        process_cmd_cache["$pid"]="$cmd"
        echo "$cmd"
    fi
}

# Get user for a process
get_process_user() {
    local pid=$1
    
    # Check cache first
    if [ -n "${process_user_cache[$pid]}" ]; then
        echo "${process_user_cache[$pid]}"
        return
    fi
    
    # Get user and cache it
    local user=$(ps -o user= -p "$pid" 2>/dev/null | tr -d ' ')
    if [ -n "$user" ]; then
        process_user_cache["$pid"]="$user"
        echo "$user"
    fi
}

# Capture baseline hashes of important binaries
capture_baseline() {
    log_message "Capturing baseline hashes of system binaries" "CRITICAL"
    
    # Check shell binaries
    for binary in "${SHELL_BINARIES[@]}"; do
        if [ -f "$binary" ]; then
            local hash=$(sha256sum "$binary" 2>/dev/null | cut -d' ' -f1)
            if [ -n "$hash" ]; then
                baseline_hashes["$binary"]="$hash"
            fi
        fi
    done
    
    # Check system binaries
    for binary in "${SYSTEM_BINARIES[@]}"; do
        if [ -f "$binary" ]; then
            local hash=$(sha256sum "$binary" 2>/dev/null | cut -d' ' -f1)
            if [ -n "$hash" ]; then
                baseline_hashes["$binary"]="$hash"
            fi
        fi
    done
    
    # Save the baseline
    save_baseline
    
    log_message "Baseline captured for ${#baseline_hashes[@]} binaries" "CRITICAL"
}

# Check if a binary has been modified
is_binary_modified() {
    local binary=$1
    
    # Skip if binary doesn't exist
    if [ ! -f "$binary" ]; then
        return 1
    fi
    
    # Check if we've already verified this binary
    if [ -n "${checked_binaries[$binary]}" ]; then
        return ${checked_binaries[$binary]}
    fi
    
    # Skip if already detected as modified
    if [ -n "${modified_binaries[$binary]}" ]; then
        checked_binaries["$binary"]=0
        return 0
    fi
    
    # Check if we have a baseline hash for this binary
    if [ -z "${baseline_hashes[$binary]}" ]; then
        # No baseline hash, consider it unmodified
        checked_binaries["$binary"]=1
        return 1
    fi
    
    # Calculate current hash
    local current_hash=$(sha256sum "$binary" 2>/dev/null | cut -d' ' -f1)
    if [ -z "$current_hash" ]; then
        # Couldn't calculate hash, consider it unmodified
        checked_binaries["$binary"]=1
        return 1
    fi
    
    # Compare with baseline
    if [ "$current_hash" != "${baseline_hashes[$binary]}" ]; then
        # Calculate threat score
        local threat_score=60  # Base score for modified binary
        local threat_details="Binary hash changed; "
        
        # Additional checks to determine severity
        
        # Check file permissions
        local perms=$(stat -c %a "$binary" 2>/dev/null)
        if [ "$perms" = "777" ] || [ "$perms" = "4777" ] || [ "$perms" = "2777" ] || [ "$perms" = "6777" ]; then
            threat_score=$((threat_score + 20))
            threat_details="${threat_details}Suspicious permissions ($perms); "
        fi
        
        # Check file owner
        local owner=$(stat -c %U "$binary" 2>/dev/null)
        if [ "$owner" != "root" ]; then
            threat_score=$((threat_score + 20))
            threat_details="${threat_details}Non-root owner ($owner); "
        fi
        
        # Check file size difference
        local size=$(stat -c %s "$binary" 2>/dev/null)
        local expected_size_range=0
        
        # Get size range from similar binaries
        for bin in "${SHELL_BINARIES[@]}" "${SYSTEM_BINARIES[@]}"; do
            if [ "$bin" != "$binary" ] && [ -f "$bin" ]; then
                local bin_size=$(stat -c %s "$bin" 2>/dev/null)
                if [ -n "$bin_size" ] && [ "$bin_size" -gt "$expected_size_range" ]; then
                    expected_size_range=$bin_size
                fi
            fi
        done
        
        # If binary is significantly larger than expected, it's suspicious
        if [ "$size" -gt $((expected_size_range * 2)) ]; then
            threat_score=$((threat_score + 15))
            threat_details="${threat_details}Abnormal size ($size bytes); "
        fi
        
        # Check for suspicious strings in binary
        if strings "$binary" 2>/dev/null | grep -q -E "connect|socket|bind|listen|accept|setuid|setgid|/etc/shadow|/etc/passwd"; then
            threat_score=$((threat_score + 15))
            threat_details="${threat_details}Contains suspicious strings; "
        fi
        
        # Store result in cache
        checked_binaries["$binary"]=0
        
        # Update threat intelligence if score is high enough
        if [ $threat_score -ge $SEVERITY_THRESHOLD ]; then
            update_threat_intel "$binary" "$current_hash" "${baseline_hashes[$binary]}" "$threat_score" "$threat_details"
        fi
        
        return 0
    fi
    
    # Binary is unmodified
    checked_binaries["$binary"]=1
    return 1
}

# Find processes using a specific binary
find_processes_using_binary() {
    local binary=$1
    local binary_name=$(basename "$binary")
    local pids=""
    
    # Reset the process map for this binary
    binary_processes["$binary"]=""
    
    # Check all processes
    for pid_dir in /proc/[0-9]*; do
        local pid=$(basename "$pid_dir")
        
        # Skip if not a valid PID
        if ! [[ "$pid" =~ ^[0-9]+$ ]]; then
            continue
        fi
        
        # Check if process is using the binary
        if [ -L "$pid_dir/exe" ]; then
            local exe_path=$(readlink -f "$pid_dir/exe" 2>/dev/null)
            if [ "$exe_path" = "$binary" ]; then
                pids="${pids} $pid"
                continue
            fi
        fi
        
        # Check mapped files
        if [ -d "$pid_dir/map_files" ]; then
            if ls -la "$pid_dir/map_files" 2>/dev/null | grep -q "$binary"; then
                pids="${pids} $pid"
                continue
            fi
        fi
        
        # Check command line
        local cmd=$(cat "$pid_dir/cmdline" 2>/dev/null | tr '\0' ' ')
        if [[ "$cmd" == *"$binary_name"* ]]; then
            # Verify it's actually using this binary and not just a similar name
            local maps=$(cat "$pid_dir/maps" 2>/dev/null)
            if [[ "$maps" == *"$binary"* ]]; then
                pids="${pids} $pid"
            fi
        fi
    done
    
    # Store in binary_processes map
    binary_processes["$binary"]="$pids"
    
    echo "$pids"
}

# Create forensic capture of modified binary
create_forensic_capture() {
    local binary=$1
    local current_hash=$2
    local original_hash=$3
    local threat_score=$4
    local threat_details=$5
    
    local timestamp=$(date +%Y%m%d%H%M%S)
    local binary_name=$(basename "$binary")
    local forensic_dir="$FORENSIC_DIR/${binary_name}_${timestamp}"
    mkdir -p "$forensic_dir" 2>/dev/null
    
    log_message "Creating forensic capture for modified binary: $binary in $forensic_dir" "CRITICAL"
    
    # Save binary information
    file "$binary" > "$forensic_dir/file_info.txt" 2>/dev/null
    stat "$binary" > "$forensic_dir/file_stats.txt" 2>/dev/null
    
    # Save a copy of the modified binary
    cp "$binary" "$forensic_dir/${binary_name}.modified" 2>/dev/null
    
    # Extract strings from binary
    strings "$binary" > "$forensic_dir/strings.txt" 2>/dev/null
    
    # Check for suspicious strings
    grep -E "connect|socket|bind|listen|accept|setuid|setgid|/etc/shadow|/etc/passwd" "$forensic_dir/strings.txt" > "$forensic_dir/suspicious_strings.txt" 2>/dev/null
    
    # Find processes using this binary
    local pids=$(find_processes_using_binary "$binary")
    if [ -n "$pids" ]; then
        echo "Processes using this binary: $pids" > "$forensic_dir/processes.txt"
        
        # Save process details
        for pid in $pids; do
            ps -p "$pid" -F >> "$forensic_dir/processes.txt" 2>/dev/null
        done
    fi
    
    # Save threat details
    {
        echo "Timestamp: $(date)"
        echo "Binary: $binary"
        echo "Current Hash: $current_hash"
        echo "Original Hash: $original_hash"
        echo "Threat Score: $threat_score"
        echo "Threat Details: $threat_details"
    } > "$forensic_dir/threat_details.txt"
    
    log_message "Forensic capture completed for $binary" "CRITICAL"
}

# Enhanced modified binary handling with multiple response options
handle_modified_binary() {
    local binary=$1
    local binary_name=$(basename "$binary")
    
    # Skip if already handled
    if [ -n "${modified_binaries[$binary]}" ]; then
        return
    fi
    
    # Mark as modified
    modified_binaries["$binary"]=1
    
    # Get current hash
    local current_hash=$(sha256sum "$binary" 2>/dev/null | cut -d' ' -f1)
    local original_hash="${baseline_hashes[$binary]}"
    
    # Calculate threat score
    local threat_score=60  # Base score for modified binary
    local threat_details="Binary hash changed; "
    
    # Check file permissions
    local perms=$(stat -c %a "$binary" 2>/dev/null)
    if [ "$perms" = "777" ] || [ "$perms" = "4777" ] || [ "$perms" = "2777" ] || [ "$perms" = "6777" ]; then
        threat_score=$((threat_score + 20))
        threat_details="${threat_details}Suspicious permissions ($perms); "
    fi
    
    # Check file owner
    local owner=$(stat -c %U "$binary" 2>/dev/null)
    if [ "$owner" != "root" ]; then
        threat_score=$((threat_score + 20))
        threat_details="${threat_details}Non-root owner ($owner); "
    fi
    
    # Log the detection with detailed information
    log_message "Modified binary detected: $binary, Original hash: $original_hash, Current hash: $current_hash" "CRITICAL"
    
    # Create forensic capture for analysis
    create_forensic_capture "$binary" "$current_hash" "$original_hash" "$threat_score" "$threat_details"
    
    # Save a copy of the modified binary for analysis
    local sample_dir="$SAMPLE_DIR/${binary_name}_${current_hash}"
    if [ ! -d "$sample_dir" ]; then
        mkdir -p "$sample_dir" 2>/dev/null
        cp "$binary" "$sample_dir/${binary_name}" 2>/dev/null
        
        # Save metadata
        {
            echo "Path: $binary"
            echo "Original Hash: $original_hash"
            echo "Modified Hash: $current_hash"
            echo "Detection Time: $(date -Iseconds)"
            echo "File Type: $(file -b "$binary" 2>/dev/null)"
            echo "Permissions: $(stat -c %a "$binary" 2>/dev/null)"
            echo "Owner: $(stat -c %U "$binary" 2>/dev/null)"
            echo "Size: $(stat -c %s "$binary" 2>/dev/null) bytes"
        } > "$sample_dir/metadata.txt"
    fi
    
    # Find processes using this binary
    local pids=$(find_processes_using_binary "$binary")
    
    # Take action based on severity and binary type
    if [ $threat_score -ge 80 ]; then
        # For critical threats, terminate processes and restore binary
        log_message "Critical binary modification detected: $binary - Terminating processes and restoring" "CRITICAL"
        
        # Terminate processes using this binary
        if [ -n "$pids" ]; then
            for pid in $pids; do
                local user=$(get_process_user "$pid")
                local cmd=$(get_process_cmd "$pid")
                log_message "Terminating process: PID=$pid, User=$user, Command=$cmd" "CRITICAL"
                kill -9 "$pid" 2>/dev/null
            done
        fi
        
        # Try to restore from package manager if available
        if command -v pacman >/dev/null 2>&1; then
            # Find which package owns this file
            local pkg=$(pacman -Qo "$binary" 2>/dev/null | awk '{print $5}')
            if [ -n "$pkg" ]; then
                log_message "Attempting to restore $binary from package $pkg" "CRITICAL"
                pacman -S --noconfirm "$pkg" >/dev/null 2>&1
            fi
        elif command -v apt >/dev/null 2>&1; then
            # Find which package owns this file
            local pkg=$(dpkg -S "$binary" 2>/dev/null | cut -d: -f1)
            if [ -n "$pkg" ]; then
                log_message "Attempting to restore $binary from package $pkg" "CRITICAL"
                apt-get install --reinstall -y "$pkg" >/dev/null 2>&1
            fi
        fi
    } elif [ $threat_score -ge $SEVERITY_THRESHOLD ]; then
        # For high severity threats, terminate processes
        log_message "High severity binary modification: $binary - Terminating processes" "CRITICAL"
        
        # Terminate processes using this binary
        if [ -n "$pids" ]; then
            for pid in $pids; do
                local user=$(get_process_user "$pid")
                local cmd=$(get_process_cmd "$pid")
                log_message "Terminating process: PID=$pid, User=$user, Command=$cmd" "CRITICAL"
                kill -9 "$pid" 2>/dev/null
            done
        fi
    } else {
        # For lower severity, just monitor
        log_message "Monitoring modified binary: $binary" "CRITICAL"
    }
}

# Generate threat intelligence report
generate_threat_report() {
    if [ -f "$INTEL_DB" ] && command -v jq >/dev/null 2>&1; then
        local threat_count=$(jq '.threats | length' "$INTEL_DB" 2>/dev/null)
        local high_threats=$(jq '.threats | to_entries[] | select(.value.severity >= 70) | .key' "$INTEL_DB" 2>/dev/null | wc -l)
        
        log_message "Rootshell Injection Threat Report: Total threats=$threat_count, High severity threats=$high_threats" "CRITICAL"
        
        # List top threats
        local top_threats=$(jq -r '.threats | to_entries | sort_by(.value.severity) | reverse | .[0:5] | .[] | "\(.key):\(.value.severity):\(.value.details)"' "$INTEL_DB" 2>/dev/null)
        if [ -n "$top_threats" ]; then
            log_message "Top rootshell injection threats:" "CRITICAL"
            while IFS=: read -r binary severity details; do
                log_message "  Binary=$binary, Severity=$severity, Details=$details" "CRITICAL"
            done <<< "$top_threats"
        fi
    fi
}

# Clean up tracking data
cleanup_tracking_data() {
    # Reset checked binaries each run
    declare -A checked_binaries
}

# Main function - enhanced with advanced detection
main() {
    log_message "Rootshell Injection Mitigator Professional started" "CRITICAL"
    
    # Use lower CPU priority
    renice 10 $$ > /dev/null 2>&1
    ionice -c3 -p $$ > /dev/null 2>&1
    
    # Load baseline
    load_baseline
    
    # Capture baseline if it doesn't exist or is empty
    if [ ${#baseline_hashes[@]} -eq 0 ]; then
        capture_baseline
    fi
    
    # Counter for maintenance operations
    local counter=0
    local report_interval=24  # Generate report every 24 cycles
    local baseline_refresh_counter=0
    
    while true; do
        # Reset checked binaries
        cleanup_tracking_data
        
        # Check for modified binaries
        local threat_count=0
        
        # Check shell binaries
        for binary in "${SHELL_BINARIES[@]}"; do
            if [ -f "$binary" ] && is_binary_modified "$binary"; then
                handle_modified_binary "$binary"
                threat_count=$((threat_count + 1))
            fi
        done
        
        # Check system binaries
        for binary in "${SYSTEM_BINARIES[@]}"; do
            if [ -f "$binary" ] && is_binary_modified "$binary"; then
                handle_modified_binary "$binary"
                threat_count=$((threat_count + 1))
            fi
        done
        
        # Log summary if threats found
        if [ $threat_count -gt 0 ]; then
            log_message "Scan complete: Detected $threat_count modified binaries" "CRITICAL"
        fi
        
        # Increment counter and perform maintenance periodically
        counter=$((counter + 1))
        baseline_refresh_counter=$((baseline_refresh_counter + SCAN_INTERVAL))
        
        # Save baseline periodically
        if [ $((counter % 10)) -eq 0 ]; then
            save_baseline
        fi
        
        # Generate threat report periodically
        if [ $((counter % report_interval)) -eq 0 ]; then
            generate_threat_report
        fi
        
        # Refresh baseline periodically
        if [ $baseline_refresh_counter -ge $BASELINE_REFRESH ]; then
            capture_baseline
            baseline_refresh_counter=0
        fi
        
        # Use adaptive sleep to reduce system load
        if [ $threat_count -gt 0 ]; then
            # More frequent checks if threats detected
            sleep 30
        else
            sleep $SCAN_INTERVAL
        fi
    done
}

# Trap signals for clean exit and reporting
trap "save_baseline; generate_threat_report; log_message 'Rootshell Injection Mitigator Hardened Fangbull stopped' 'CRITICAL'; exit 0" SIGTERM SIGINT

main 