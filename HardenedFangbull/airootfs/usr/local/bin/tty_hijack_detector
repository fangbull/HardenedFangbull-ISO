#!/bin/bash

# TTY Hijack/Clone Detector - Hardened Fangbull
# Advanced detection and prevention of unauthorized TTY access and session hijacking

# Configuration
LOG_FILE="/var/log/fangbull-ids/tty_hijack.log"
LOG_MAX_SIZE=5242880  # 5MB max log size
CACHE_FILE="/var/log/fangbull-ids/tty_hijack.cache"
SESSION_DB="/var/log/fangbull-ids/tty_sessions.db"
FORENSIC_DIR="/var/log/fangbull-ids/tty_forensics"
SCAN_INTERVAL=45      # Seconds between scans
HISTORY_RETENTION=30  # Days to keep session history
SEVERITY_THRESHOLD=70 # Severity score threshold for action

# Create required directories
mkdir -p "$(dirname "$LOG_FILE")" 2>/dev/null
mkdir -p "$FORENSIC_DIR" 2>/dev/null

# Rotate log if it exceeds max size
rotate_log() {
    if [ -f "$LOG_FILE" ] && [ $(stat -c%s "$LOG_FILE" 2>/dev/null || echo 0) -gt $LOG_MAX_SIZE ]; then
        local timestamp=$(date +%Y%m%d%H%M%S)
        mv "$LOG_FILE" "$LOG_FILE.$timestamp" 2>/dev/null
        gzip -f "$LOG_FILE.$timestamp" 2>/dev/null
    fi
}

log_message() {
    # Only log critical events
    if [ "$2" = "CRITICAL" ]; then
        local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
        echo "[$timestamp] $1" >> "$LOG_FILE"
        rotate_log
    fi
}

# Advanced data structures for TTY session tracking
declare -A legitimate_ttys        # Known legitimate sessions
declare -A suspicious_ttys        # Suspicious sessions
declare -A session_history        # Historical session data
declare -A user_session_count     # Count of sessions per user
declare -A tty_process_map        # Map TTYs to their controlling processes

# Load cache if it exists
if [ -f "$CACHE_FILE" ]; then
    while IFS=: read -r type data; do
        if [ "$type" = "LEGITIMATE" ]; then
            IFS='|' read -r key pid timestamp user cmd <<< "$data"
            legitimate_ttys["$key"]="$pid:$timestamp:$user:$cmd"
        elif [ "$type" = "SUSPICIOUS" ]; then
            IFS='|' read -r key timestamp severity <<< "$data"
            suspicious_ttys["$key"]="$timestamp:$severity"
        fi
    done < "$CACHE_FILE"
fi

# Load session database if it exists
load_session_db() {
    if [ -f "$SESSION_DB" ] && command -v jq >/dev/null 2>&1; then
        # Extract session history
        local sessions=$(jq -r '.sessions | to_entries[] | "\(.key):\(.value.pid):\(.value.user):\(.value.start_time)"' "$SESSION_DB" 2>/dev/null)
        if [ -n "$sessions" ]; then
            while IFS=: read -r key pid user start_time; do
                session_history["$key"]="$pid:$user:$start_time"
            done <<< "$sessions"
        fi
    fi
}

# Save cache periodically
save_cache() {
    # Create temp file first to avoid race conditions
    local tmp_file=$(mktemp)
    
    # Save legitimate sessions
    for key in "${!legitimate_ttys[@]}"; do
        local data="${legitimate_ttys[$key]}"
        echo "LEGITIMATE:$key|$data" >> "$tmp_file"
    done
    
    # Save suspicious sessions (limit to recent ones)
    local current_time=$(date +%s)
    for key in "${!suspicious_ttys[@]}"; do
        local data="${suspicious_ttys[$key]}"
        IFS=: read -r timestamp severity <<< "$data"
        
        # Only keep entries from the last 24 hours
        if (( current_time - timestamp < 86400 )); then
            echo "SUSPICIOUS:$key|$timestamp:$severity" >> "$tmp_file"
        fi
    done
    
    # Atomic update
    mv "$tmp_file" "$CACHE_FILE" 2>/dev/null
}

# Update session database
update_session_db() {
    local session_key=$1
    local pid=$2
    local tty=$3
    local user=$4
    local cmd=$5
    local action=$6
    local details=$7
    local timestamp=$(date -Iseconds)
    local epoch_time=$(date +%s)
    
    # Create temp file for atomic write
    local tmp_file=$(mktemp)
    
    # Use jq if available for proper JSON handling
    if command -v jq >/dev/null 2>&1; then
        if [ -f "$SESSION_DB" ]; then
            jq --arg key "$session_key" \
               --arg pid "$pid" \
               --arg tty "$tty" \
               --arg user "$user" \
               --arg cmd "$cmd" \
               --arg action "$action" \
               --arg details "$details" \
               --arg time "$timestamp" \
               --arg epoch "$epoch_time" \
            '.sessions[$key] = {
                "pid": $pid,
                "tty": $tty,
                "user": $user,
                "command": $cmd,
                "action": $action,
                "details": $details,
                "timestamp": $time,
                "epoch_time": ($epoch|tonumber),
                "start_time": (.sessions[$key].start_time // $time)
             } | .metadata.last_update = $time' \
            "$SESSION_DB" > "$tmp_file" 2>/dev/null
            
            # Prune old sessions
            if [ -s "$tmp_file" ]; then
                local cutoff_time=$(($(date +%s) - (HISTORY_RETENTION * 86400)))
                jq --arg cutoff "$cutoff_time" \
                   'del(.sessions[] | select(.epoch_time < ($cutoff|tonumber)))' \
                   "$tmp_file" > "${tmp_file}.new"
                if [ -s "${tmp_file}.new" ]; then
                    mv "${tmp_file}.new" "$tmp_file"
                fi
            fi
        else
            echo "{\"sessions\":{\"$session_key\":{\"pid\":\"$pid\",\"tty\":\"$tty\",\"user\":\"$user\",\"command\":\"$cmd\",\"action\":\"$action\",\"details\":\"$details\",\"timestamp\":\"$timestamp\",\"epoch_time\":$epoch_time,\"start_time\":\"$timestamp\"}},\"metadata\":{\"last_update\":\"$timestamp\"}}" > "$tmp_file"
        fi
    else
        # Simple fallback if jq not available
        echo "{\"sessions\":{\"$session_key\":{\"pid\":\"$pid\",\"tty\":\"$tty\",\"user\":\"$user\",\"command\":\"$cmd\",\"action\":\"$action\",\"details\":\"$details\",\"timestamp\":\"$timestamp\",\"epoch_time\":$epoch_time,\"start_time\":\"$timestamp\"}},\"metadata\":{\"last_update\":\"$timestamp\"}}" > "$tmp_file"
    fi
    
    # Atomic update
    if [ -s "$tmp_file" ]; then
        mv "$tmp_file" "$SESSION_DB"
    else
        rm -f "$tmp_file"
    fi
}

# Advanced TTY legitimacy checking with multiple verification methods
is_legitimate_tty() {
    local tty=$1
    local user=$2
    local pid=$3
    
    # Skip pseudo-terminals used by system services
    if [[ "$tty" == "?" ]] || [[ "$tty" == "-" ]] || [[ -z "$tty" ]]; then
        return 0
    fi
    
    # Calculate threat score for this TTY session
    local threat_score=0
    local threat_details=""
    
    # Check if this is a known legitimate session
    local key="${tty}:${user}"
    if [[ -n "${legitimate_ttys[$key]}" ]]; then
        IFS=: read -r known_pid timestamp known_user cmd <<< "${legitimate_ttys[$key]}"
        
        # Check if the PID matches
        if [[ "$known_pid" == "$pid" ]]; then
            # Update timestamp for active session
            legitimate_ttys["$key"]="$pid:$(date +%s):$user:$cmd"
            return 0
        else
            # PID changed for same TTY/user - potential hijack
            threat_score=$((threat_score + 60))
            threat_details="${threat_details}PID changed for same TTY/user (old: $known_pid, new: $pid); "
        fi
    fi
    
    # New session - perform advanced legitimacy checks
    
    # Check process ancestry
    local ppid=$(ps -o ppid= -p "$pid" 2>/dev/null | tr -d ' ')
    local pname=$(ps -o comm= -p "$ppid" 2>/dev/null)
    
    # Get command line for forensics
    local cmd=$(ps -o cmd= -p "$pid" 2>/dev/null)
    
    # Legitimate parent processes for TTY sessions - comprehensive list
    local legitimate_parents=(
        "login" "sshd" "gdm-session-worker" "lightdm" "xdm" "kdm" "slim" "lxdm"
        "gnome-terminal" "konsole" "xterm" "rxvt" "terminator" "alacritty" "kitty"
        "tmux" "screen" "systemd" "su" "sudo" "xfce4-terminal" "tilix" "urxvt"
        "gnome-shell" "kwin" "xfwm4" "i3" "sway" "openbox" "fluxbox" "awesome"
    )
    
    local is_legitimate_parent=0
    for parent in "${legitimate_parents[@]}"; do
        if [[ "$pname" == "$parent"* ]]; then
            is_legitimate_parent=1
            break
        fi
    done
    
    if [ $is_legitimate_parent -eq 0 ]; then
        threat_score=$((threat_score + 40))
        threat_details="${threat_details}Suspicious parent process: $pname; "
    fi
    
    # Check for session anomalies
    
    # Check user session count - unusual number of sessions for a user is suspicious
    if [ -z "${user_session_count[$user]}" ]; then
        user_session_count["$user"]=1
    else
        local count=${user_session_count[$user]}
        user_session_count["$user"]=$((count + 1))
        
        # More than 10 sessions for a single user is suspicious
        if [ $count -gt 10 ]; then
            threat_score=$((threat_score + 20))
            threat_details="${threat_details}Excessive sessions for user: $user ($count sessions); "
        fi
    fi
    
    # Check for unusual TTY names
    if [[ ! "$tty" =~ ^(pts/[0-9]+|tty[0-9]+)$ ]]; then
        threat_score=$((threat_score + 30))
        threat_details="${threat_details}Unusual TTY name: $tty; "
    fi
    
    # Check for suspicious commands in TTY session
    local suspicious_cmds=("nc " "netcat " "socat " "nmap " "wireshark " "tcpdump " "ettercap " "hydra " "john " "hashcat ")
    for scmd in "${suspicious_cmds[@]}"; do
        if [[ "$cmd" == *"$scmd"* ]]; then
            threat_score=$((threat_score + 15))
            threat_details="${threat_details}Suspicious command: $scmd; "
            break
        fi
    done
    
    # Check for user privilege inconsistencies
    if [[ "$user" != "root" ]]; then
        # Check if process is running as a different user than the TTY owner
        local process_user=$(ps -o user= -p "$pid" 2>/dev/null | tr -d ' ')
        if [[ "$process_user" != "$user" ]]; then
            threat_score=$((threat_score + 50))
            threat_details="${threat_details}User mismatch: TTY owner=$user, Process owner=$process_user; "
        fi
    fi
    
    # Check for short-lived processes - might be legitimate
    local uptime=$(ps -o etimes= -p "$pid" 2>/dev/null | tr -d ' ')
    if [ -n "$uptime" ] && [ "$uptime" -lt 5 ]; then
        # Reduce threat score for very new processes
        threat_score=$((threat_score - 20))
        if [ $threat_score -lt 0 ]; then
            threat_score=0
        fi
    fi
    
    # Make decision based on threat score
    if [ $threat_score -ge $SEVERITY_THRESHOLD ]; then
        # High threat - record as suspicious
        suspicious_ttys["$key"]="$(date +%s):$threat_score"
        
        # Log the suspicious session
        update_session_db "$key" "$pid" "$tty" "$user" "$cmd" "suspicious" "$threat_details"
        
        return 1
    else
        # Register as legitimate
        legitimate_ttys["$key"]="$pid:$(date +%s):$user:$cmd"
        
        # Log the legitimate session
        update_session_db "$key" "$pid" "$tty" "$user" "$cmd" "legitimate" ""
        
        return 0
    fi
}

# Create forensic capture of suspicious TTY session
create_forensic_capture() {
    local pid=$1
    local tty=$2
    local user=$3
    local threat_score=$4
    local threat_details=$5
    
    local timestamp=$(date +%Y%m%d%H%M%S)
    local forensic_dir="$FORENSIC_DIR/tty_${tty//\//_}_pid_${pid}_${timestamp}"
    mkdir -p "$forensic_dir" 2>/dev/null
    
    log_message "Creating forensic capture for suspicious TTY: $tty, PID=$pid in $forensic_dir" "CRITICAL"
    
    # Save basic process information
    ps -p "$pid" -F > "$forensic_dir/process_info.txt" 2>/dev/null
    
    # Save process tree
    pstree -p "$pid" > "$forensic_dir/process_tree.txt" 2>/dev/null
    
    # Save environment variables
    if [ -f "/proc/$pid/environ" ]; then
        tr '\0' '\n' < "/proc/$pid/environ" > "$forensic_dir/environment.txt" 2>/dev/null
    fi
    
    # Save open files
    if command -v lsof >/dev/null 2>&1; then
        lsof -p "$pid" > "$forensic_dir/open_files.txt" 2>/dev/null
    fi
    
    # Save network connections
    if command -v ss >/dev/null 2>&1; then
        ss -p | grep "$pid" > "$forensic_dir/network_connections.txt" 2>/dev/null
    fi
    
    # Save command history if available
    if [ -n "$user" ] && [ "$user" != "root" ] && [ -f "/home/$user/.bash_history" ]; then
        cp "/home/$user/.bash_history" "$forensic_dir/bash_history.txt" 2>/dev/null
    fi
    
    # Save threat details
    {
        echo "Timestamp: $(date)"
        echo "TTY: $tty"
        echo "PID: $pid"
        echo "User: $user"
        echo "Threat Score: $threat_score"
        echo "Threat Details: $threat_details"
        echo "Command: $(ps -o cmd= -p "$pid" 2>/dev/null)"
        echo "Parent Process: $(ps -o ppid= -p "$pid" 2>/dev/null | xargs ps -o comm= -p 2>/dev/null)"
        echo "Session Start: $(ps -o lstart= -p "$pid" 2>/dev/null)"
    } > "$forensic_dir/threat_details.txt"
    
    log_message "Forensic capture completed for TTY $tty" "CRITICAL"
}

# Enhanced suspicious TTY handling with multiple response options
handle_suspicious_tty() {
    local pid=$1
    local tty=$2
    local user=$3
    local cmd=$(ps -o cmd= -p "$pid" 2>/dev/null)
    
    # Get threat score from suspicious_ttys
    local key="${tty}:${user}"
    local threat_score=0
    local threat_details=""
    
    if [[ -n "${suspicious_ttys[$key]}" ]]; then
        IFS=: read -r timestamp threat_score <<< "${suspicious_ttys[$key]}"
    fi
    
    # Skip if we've already handled this suspicious session recently
    local current_time=$(date +%s)
    if (( current_time - timestamp < 300 )); then
        return
    fi
    
    # Mark as handled with current timestamp
    suspicious_ttys["$key"]="$current_time:$threat_score"
    
    # Log critical event with severity information
    if [ $threat_score -ge 90 ]; then
        log_message "CRITICAL TTY HIJACK: TTY=$tty, PID=$pid, User=$user, Score=$threat_score" "CRITICAL"
    else
        log_message "Suspicious TTY session: TTY=$tty, PID=$pid, User=$user, Score=$threat_score" "CRITICAL"
    fi
    
    # Create forensic capture for analysis
    create_forensic_capture "$pid" "$tty" "$user" "$threat_score" "$threat_details"
    
    # Take action based on severity
    if [ $threat_score -ge 90 ]; then
        # For critical threats, terminate the process and its children
        log_message "Terminating process tree for critical TTY hijack: PID=$pid" "CRITICAL"
        pkill -9 -P "$pid" 2>/dev/null  # Kill children first
        kill -9 "$pid" 2>/dev/null      # Then kill the parent
        
        # Update session database
        update_session_db "$key" "$pid" "$tty" "$user" "$cmd" "terminated" "Critical TTY hijack detected"
    elif [ $threat_score -ge $SEVERITY_THRESHOLD ]; then
        # For high severity threats, kill non-root processes
        if [ "$user" != "root" ]; then
            log_message "Terminating suspicious TTY session: PID=$pid" "CRITICAL"
            kill -9 "$pid" 2>/dev/null
            
            # Update session database
            update_session_db "$key" "$pid" "$tty" "$user" "$cmd" "terminated" "High severity TTY anomaly"
        else
            log_message "WARNING: Not terminating root-owned suspicious TTY: $tty" "CRITICAL"
            
            # Update session database
            update_session_db "$key" "$pid" "$tty" "$user" "$cmd" "monitored" "Root-owned suspicious TTY"
        fi
    else
        # For lower severity, just monitor
        update_session_db "$key" "$pid" "$tty" "$user" "$cmd" "monitored" "Low severity TTY anomaly"
    fi
}

# Generate session activity report
generate_session_report() {
    if [ -f "$SESSION_DB" ] && command -v jq >/dev/null 2>&1; then
        local total_sessions=$(jq '.sessions | length' "$SESSION_DB" 2>/dev/null)
        local suspicious_count=$(jq '.sessions | to_entries[] | select(.value.action == "suspicious" or .value.action == "terminated") | .key' "$SESSION_DB" 2>/dev/null | wc -l)
        
        log_message "TTY Session Report: Total sessions=$total_sessions, Suspicious sessions=$suspicious_count" "CRITICAL"
        
        # List recent suspicious sessions
        local recent_suspicious=$(jq -r '.sessions | to_entries[] | select(.value.action == "suspicious" or .value.action == "terminated") | sort_by(.value.epoch_time) | reverse | .[0:5] | .[] | "\(.value.tty):\(.value.user):\(.value.action):\(.value.details)"' "$SESSION_DB" 2>/dev/null)
        if [ -n "$recent_suspicious" ]; then
            log_message "Recent suspicious TTY sessions:" "CRITICAL"
            while IFS=: read -r tty user action details; do
                log_message "  TTY=$tty, User=$user, Action=$action" "CRITICAL"
            done <<< "$recent_suspicious"
        fi
    fi
}

# Clean up stale entries
cleanup_stale_entries() {
    # Clean up legitimate TTY sessions for non-existent PIDs
    local stale_keys=()
    
    for key in "${!legitimate_ttys[@]}"; do
        IFS=: read -r pid timestamp user cmd <<< "${legitimate_ttys[$key]}"
        if [ ! -e "/proc/$pid" ]; then
            stale_keys+=("$key")
        fi
    done
    
    for key in "${stale_keys[@]}"; do
        unset legitimate_ttys["$key"]
    done
    
    # Clean up suspicious TTY tracking (keep for forensic purposes)
    local current_time=$(date +%s)
    stale_keys=()
    
    for key in "${!suspicious_ttys[@]}"; do
        IFS=: read -r timestamp score <<< "${suspicious_ttys[$key]}"
        # Remove entries older than 24 hours
        if (( current_time - timestamp > 86400 )); then
            stale_keys+=("$key")
        fi
    done
    
    for key in "${stale_keys[@]}"; do
        unset suspicious_ttys["$key"]
    done
    
    # Reset session counts
    declare -A user_session_count
}

# Main function - enhanced with advanced detection
main() {
    log_message "TTY Hijack/Clone Detector Professional started" "CRITICAL"
    
    # Use lower CPU priority
    renice 10 $$ > /dev/null 2>&1
    ionice -c3 -p $$ > /dev/null 2>&1
    
    # Load session database
    load_session_db
    
    # Counter for maintenance operations
    local counter=0
    local report_interval=24  # Generate report every 24 cycles
    local cleanup_interval=5  # Clean caches every 5 cycles
    
    # Initial scan to populate legitimate sessions - minimal logging
    while read -r pid tty user cmd; do
        if [[ -n "$tty" && "$tty" != "TTY" ]]; then
            is_legitimate_tty "$tty" "$user" "$pid"
        fi
    done < <(ps -eo pid,tty,user,cmd)
    
    # Main monitoring loop
    while true; do
        # Reset session count for this scan
        declare -A user_session_count
        
        # Check all TTY sessions
        while read -r pid tty user cmd; do
            if [[ -n "$tty" && "$tty" != "TTY" && "$tty" != "?" && "$tty" != "-" ]]; then
                # Map TTY to process
                tty_process_map["$tty"]="$pid"
                
                # Check legitimacy
                if ! is_legitimate_tty "$tty" "$user" "$pid"; then
                    handle_suspicious_tty "$pid" "$tty" "$user"
                fi
            fi
        done < <(ps -eo pid,tty,user,cmd)
        
        # Increment counter and perform maintenance periodically
        counter=$((counter + 1))
        
        # Clean caches periodically
        if [ $((counter % cleanup_interval)) -eq 0 ]; then
            cleanup_stale_entries
        fi
        
        # Save cache periodically
        if [ $((counter % 10)) -eq 0 ]; then
            save_cache
        fi
        
        # Generate session report periodically
        if [ $((counter % report_interval)) -eq 0 ]; then
            generate_session_report
        fi
        
        # Sleep to reduce system load
        sleep $SCAN_INTERVAL
    done
}

# Trap signals for clean exit and reporting
trap "save_cache; generate_session_report; log_message 'TTY Hijack/Clone Detector Hardened Fangbull stopped' 'CRITICAL'; exit 0" SIGTERM SIGINT

main 