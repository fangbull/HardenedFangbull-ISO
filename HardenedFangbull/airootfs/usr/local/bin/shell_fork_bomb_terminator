#!/bin/bash

# Shell Fork Bomb Terminator - Hardened Fangbull
# Advanced detection and prevention of process fork bombs and resource exhaustion attacks

# Configuration
LOG_FILE="/var/log/fangbull-ids/fork_bomb.log"
LOG_MAX_SIZE=5242880  # 5MB max log size
CACHE_FILE="/var/log/fangbull-ids/fork_bomb.cache"
FORENSIC_DIR="/var/log/fangbull-ids/fork_bomb_forensics"
SCAN_INTERVAL=8       # Seconds between scans (lower for faster response)
INTEL_DB="/var/log/fangbull-ids/process_abuse.db"
GROWTH_THRESHOLD=15   # Process growth threshold per scan interval
CHILD_THRESHOLD=50    # Child process threshold
PROCESS_HISTORY_SIZE=1000  # Maximum number of processes to track

# Create required directories
mkdir -p "$(dirname "$LOG_FILE")" 2>/dev/null
mkdir -p "$FORENSIC_DIR" 2>/dev/null

# Rotate log if it exceeds max size
rotate_log() {
    if [ -f "$LOG_FILE" ] && [ $(stat -c%s "$LOG_FILE" 2>/dev/null || echo 0) -gt $LOG_MAX_SIZE ]; then
        local timestamp=$(date +%Y%m%d%H%M%S)
        mv "$LOG_FILE" "$LOG_FILE.$timestamp" 2>/dev/null
        gzip -f "$LOG_FILE.$timestamp" 2>/dev/null
    fi
}

log_message() {
    # Only log critical events
    if [ "$2" = "CRITICAL" ]; then
        local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
        echo "[$timestamp] $1" >> "$LOG_FILE"
        rotate_log
    fi
}

# Advanced data structures for process tracking
declare -A process_children_count    # Current child count per PID
declare -A process_prev_count        # Previous child count per PID
declare -A process_growth_rate       # Growth rate per PID
declare -A process_exempt            # Exempt processes
declare -A process_cmd_cache         # Cache for process commands
declare -A process_user_cache        # Cache for process users
declare -A process_start_time        # Track when we started monitoring a process
declare -A process_child_cmd_count   # Count of child processes with same command

# Load cache if it exists
load_cache() {
    if [ -f "$CACHE_FILE" ]; then
        while IFS=: read -r type data; do
            if [ "$type" = "EXEMPT" ]; then
                process_exempt["$data"]=1
            fi
        done < "$CACHE_FILE"
    fi
}

# Save cache periodically
save_cache() {
    # Create temp file first to avoid race conditions
    local tmp_file=$(mktemp)
    
    # Save exempt processes
    for pid in "${!process_exempt[@]}"; do
        echo "EXEMPT:$pid" >> "$tmp_file"
    done
    
    # Atomic update
    mv "$tmp_file" "$CACHE_FILE" 2>/dev/null
}

# Update threat intelligence database
update_threat_intel() {
    local pid=$1
    local cmd=$2
    local user=$3
    local child_count=$4
    local growth_rate=$5
    local details=$6
    local timestamp=$(date -Iseconds)
    
    # Create temp file for atomic write
    local tmp_file=$(mktemp)
    
    # Use jq if available for proper JSON handling
    if command -v jq >/dev/null 2>&1; then
        if [ -f "$INTEL_DB" ]; then
            jq --arg pid "$pid" \
               --arg cmd "$cmd" \
               --arg user "$user" \
               --arg count "$child_count" \
               --arg rate "$growth_rate" \
               --arg details "$details" \
               --arg time "$timestamp" \
            '.threats[$pid] = {
                "command": $cmd,
                "user": $user,
                "child_count": ($count|tonumber),
                "growth_rate": ($rate|tonumber),
                "details": $details,
                "timestamp": $time
             } | .metadata.last_update = $time' \
            "$INTEL_DB" > "$tmp_file" 2>/dev/null
        else
            echo "{\"threats\":{\"$pid\":{\"command\":\"$cmd\",\"user\":\"$user\",\"child_count\":$child_count,\"growth_rate\":$growth_rate,\"details\":\"$details\",\"timestamp\":\"$timestamp\"}},\"metadata\":{\"last_update\":\"$timestamp\"}}" > "$tmp_file"
        fi
    else
        # Simple fallback if jq not available
        echo "{\"threats\":{\"$pid\":{\"command\":\"$cmd\",\"user\":\"$user\",\"child_count\":$child_count,\"growth_rate\":$growth_rate,\"details\":\"$details\",\"timestamp\":\"$timestamp\"}},\"metadata\":{\"last_update\":\"$timestamp\"}}" > "$tmp_file"
    fi
    
    # Atomic update
    if [ -s "$tmp_file" ]; then
        mv "$tmp_file" "$INTEL_DB"
    else
        rm -f "$tmp_file"
    fi
}

# Get child process count with optimized approach
get_child_count() {
    local pid=$1
    local count=0
    
    # Use find to get all processes
    count=$(find /proc -maxdepth 1 -regex "/proc/[0-9]+" -printf "%f\n" 2>/dev/null | 
            xargs -I{} grep -l "^PPid:[[:space:]]*$pid$" /proc/{}/status 2>/dev/null | 
            wc -l)
    
    echo "$count"
}

# Get command line for a process
get_process_cmd() {
    local pid=$1
    
    # Check cache first
    if [ -n "${process_cmd_cache[$pid]}" ]; then
        echo "${process_cmd_cache[$pid]}"
        return
    fi
    
    # Get command and cache it
    local cmd=$(ps -o comm= -p "$pid" 2>/dev/null)
    if [ -n "$cmd" ]; then
        process_cmd_cache["$pid"]="$cmd"
        echo "$cmd"
    fi
}

# Get user for a process
get_process_user() {
    local pid=$1
    
    # Check cache first
    if [ -n "${process_user_cache[$pid]}" ]; then
        echo "${process_user_cache[$pid]}"
        return
    fi
    
    # Get user and cache it
    local user=$(ps -o user= -p "$pid" 2>/dev/null | tr -d ' ')
    if [ -n "$user" ]; then
        process_user_cache["$pid"]="$user"
        echo "$user"
    fi
}

# Check if a process is exempt from fork bomb detection
is_exempt_process() {
    local pid=$1
    local cmd=$(get_process_cmd "$pid")
    local user=$(get_process_user "$pid")
    
    # Check if already marked as exempt
    if [ -n "${process_exempt[$pid]}" ]; then
        return 0
    fi
    
    # System processes are exempt
    if [ "$pid" -le 2 ] || [ "$user" = "root" ] && [ "$pid" -le 1000 ]; then
        process_exempt["$pid"]=1
        return 0
    fi
    
    # Common system services that spawn many processes
    local system_processes=("systemd" "init" "upstart" "kthreadd" "kworker" "ksoftirqd" "migration" "watchdog" "jbd2")
    for proc in "${system_processes[@]}"; do
        if [[ "$cmd" == "$proc"* ]]; then
            process_exempt["$pid"]=1
            return 0
        fi
    done
    
    # Common build processes that legitimately spawn many processes
    local build_processes=("make" "gcc" "g++" "cc" "javac" "mvn" "gradle" "npm" "yarn" "cargo" "rustc")
    for proc in "${build_processes[@]}"; do
        if [[ "$cmd" == "$proc"* ]]; then
            process_exempt["$pid"]=1
            return 0
        fi
    done
    
    # Check for short-lived processes
    local uptime=$(ps -o etimes= -p "$pid" 2>/dev/null | tr -d ' ')
    if [ -n "$uptime" ] && [ "$uptime" -lt 5 ]; then
        # Very new processes get a grace period
        return 0
    fi
    
    # Check if this is a daemon process
    if ps -o stat= -p "$pid" 2>/dev/null | grep -q "s"; then
        # Daemon processes are less likely to be fork bombs
        process_exempt["$pid"]=1
        return 0
    fi
    
    return 1
}

# Check if process children have the same command (common in fork bombs)
check_child_commands() {
    local pid=$1
    local parent_cmd=$(get_process_cmd "$pid")
    local same_cmd_count=0
    local total_checked=0
    
    # Reset the counter
    process_child_cmd_count["$pid"]=0
    
    # Get child PIDs
    local child_pids=$(find /proc -maxdepth 1 -regex "/proc/[0-9]+" -printf "%f\n" 2>/dev/null | 
                      xargs -I{} grep -l "^PPid:[[:space:]]*$pid$" /proc/{}/status 2>/dev/null | 
                      sed 's/\/proc\///g' | sed 's/\/status//g')
    
    # Check each child's command
    for child_pid in $child_pids; do
        local child_cmd=$(get_process_cmd "$child_pid")
        if [ "$child_cmd" = "$parent_cmd" ]; then
            same_cmd_count=$((same_cmd_count + 1))
        fi
        total_checked=$((total_checked + 1))
    done
    
    # Store the count for future reference
    process_child_cmd_count["$pid"]="$same_cmd_count:$total_checked"
    
    # If more than 80% of children have the same command as parent, it's suspicious
    if [ $total_checked -gt 0 ] && [ $same_cmd_count -gt $(( total_checked * 8 / 10 )) ]; then
        return 0
    fi
    
    return 1
}

# Advanced fork bomb detection with multiple heuristics
is_fork_bomb() {
    local pid=$1
    local child_count=$2
    
    # Skip exempt processes
    if is_exempt_process "$pid"; then
        return 1
    fi
    
    # Calculate growth rate
    local prev_count=0
    if [ -n "${process_prev_count[$pid]}" ]; then
        prev_count=${process_prev_count[$pid]}
    fi
    
    local growth_rate=$((child_count - prev_count))
    process_prev_count["$pid"]=$child_count
    process_growth_rate["$pid"]=$growth_rate
    
    # Track when we started monitoring this process
    if [ -z "${process_start_time[$pid]}" ]; then
        process_start_time["$pid"]=$(date +%s)
    fi
    
    # Check if the growth rate exceeds the threshold
    if [ $growth_rate -ge $GROWTH_THRESHOLD ]; then
        # Secondary check: do child processes have the same command?
        if check_child_commands "$pid"; then
            return 0
        fi
    fi
    
    # Check if the absolute number of children is very high
    if [ $child_count -ge $CHILD_THRESHOLD ]; then
        # Secondary check: do child processes have the same command?
        if check_child_commands "$pid"; then
            return 0
        fi
    fi
    
    return 1
}

# Create forensic capture of fork bomb
create_forensic_capture() {
    local pid=$1
    local child_count=$2
    local growth_rate=$3
    
    local timestamp=$(date +%Y%m%d%H%M%S)
    local forensic_dir="$FORENSIC_DIR/pid_${pid}_${timestamp}"
    mkdir -p "$forensic_dir" 2>/dev/null
    
    log_message "Creating forensic capture for fork bomb: PID=$pid in $forensic_dir" "CRITICAL"
    
    # Save basic process information
    ps -p "$pid" -F > "$forensic_dir/process_info.txt" 2>/dev/null
    
    # Save process tree
    pstree -p "$pid" > "$forensic_dir/process_tree.txt" 2>/dev/null
    
    # Save a sample of child processes
    ps --ppid "$pid" -F > "$forensic_dir/child_processes.txt" 2>/dev/null
    
    # Save command line and environment
    if [ -f "/proc/$pid/cmdline" ]; then
        cat "/proc/$pid/cmdline" | tr '\0' ' ' > "$forensic_dir/cmdline.txt" 2>/dev/null
    fi
    
    if [ -f "/proc/$pid/environ" ]; then
        tr '\0' '\n' < "/proc/$pid/environ" > "$forensic_dir/environment.txt" 2>/dev/null
    fi
    
    # Save executable info
    if [ -L "/proc/$pid/exe" ]; then
        local exe_path=$(readlink -f "/proc/$pid/exe" 2>/dev/null)
        echo "Executable: $exe_path" > "$forensic_dir/executable.txt"
        file "$exe_path" >> "$forensic_dir/executable.txt" 2>/dev/null
    fi
    
    # Save working directory
    if [ -L "/proc/$pid/cwd" ]; then
        local cwd_path=$(readlink -f "/proc/$pid/cwd" 2>/dev/null)
        echo "Working directory: $cwd_path" > "$forensic_dir/cwd.txt"
    fi
    
    # Save open files
    if command -v lsof >/dev/null 2>&1; then
        lsof -p "$pid" > "$forensic_dir/open_files.txt" 2>/dev/null
    fi
    
    # Save detection details
    {
        echo "Timestamp: $(date)"
        echo "PID: $pid"
        echo "Command: $(ps -o cmd= -p "$pid" 2>/dev/null)"
        echo "User: $(ps -o user= -p "$pid" 2>/dev/null)"
        echo "Child Count: $child_count"
        echo "Growth Rate: $growth_rate"
        echo "Process Start Time: $(ps -o lstart= -p "$pid" 2>/dev/null)"
        echo "Monitoring Start Time: $(date -d @${process_start_time[$pid]})"
        
        if [ -n "${process_child_cmd_count[$pid]}" ]; then
            IFS=: read -r same_cmd total_checked <<< "${process_child_cmd_count[$pid]}"
            echo "Children with same command: $same_cmd out of $total_checked"
        fi
    } > "$forensic_dir/detection_details.txt"
    
    log_message "Forensic capture completed for PID $pid" "CRITICAL"
}

# Enhanced fork bomb termination with progressive approach
terminate_fork_bomb() {
    local pid=$1
    local child_count=$2
    local growth_rate=$3
    local cmd=$(get_process_cmd "$pid")
    local user=$(get_process_user "$pid")
    
    # Log the detection with detailed information
    log_message "Fork bomb detected: PID=$pid, User=$user, Command=$cmd, Children=$child_count, Growth rate=$growth_rate/scan" "CRITICAL"
    
    # Create forensic capture for analysis
    create_forensic_capture "$pid" "$child_count" "$growth_rate"
    
    # Update threat intelligence
    local details="Fork bomb with $child_count children growing at $growth_rate processes per scan"
    if [ -n "${process_child_cmd_count[$pid]}" ]; then
        IFS=: read -r same_cmd total_checked <<< "${process_child_cmd_count[$pid]}"
        details="$details; $same_cmd/$total_checked children with same command"
    fi
    update_threat_intel "$pid" "$cmd" "$user" "$child_count" "$growth_rate" "$details"
    
    # Progressive termination strategy
    log_message "Terminating fork bomb process tree: PID=$pid" "CRITICAL"
    
    # Step 1: Try SIGTERM on parent first
    kill -15 "$pid" 2>/dev/null
    
    # Wait briefly to see if it terminates gracefully
    sleep 0.5
    
    # Step 2: If still running, use SIGKILL on children first
    if ps -p "$pid" >/dev/null 2>&1; then
        log_message "SIGTERM failed, using SIGKILL on children of PID=$pid" "CRITICAL"
        pkill -9 -P "$pid" 2>/dev/null
        
        # Wait briefly again
        sleep 0.5
        
        # Step 3: Finally kill the parent with SIGKILL if still running
        if ps -p "$pid" >/dev/null 2>&1; then
            log_message "Terminating parent process with SIGKILL: PID=$pid" "CRITICAL"
            kill -9 "$pid" 2>/dev/null
        fi
    fi
    
    # Verify termination
    if ! ps -p "$pid" >/dev/null 2>&1; then
        log_message "Successfully terminated fork bomb: PID=$pid" "CRITICAL"
    else
        log_message "WARNING: Failed to terminate fork bomb: PID=$pid" "CRITICAL"
    fi
}

# Generate threat intelligence report
generate_threat_report() {
    if [ -f "$INTEL_DB" ] && command -v jq >/dev/null 2>&1; then
        local threat_count=$(jq '.threats | length' "$INTEL_DB" 2>/dev/null)
        
        log_message "Fork Bomb Threat Report: Total incidents=$threat_count" "CRITICAL"
        
        # List top threats by child count
        local top_threats=$(jq -r '.threats | to_entries | sort_by(.value.child_count) | reverse | .[0:5] | .[] | "\(.value.command):\(.value.user):\(.value.child_count):\(.value.growth_rate)"' "$INTEL_DB" 2>/dev/null)
        if [ -n "$top_threats" ]; then
            log_message "Top fork bomb incidents:" "CRITICAL"
            while IFS=: read -r cmd user count rate; do
                log_message "  Command=$cmd, User=$user, Children=$count, Growth rate=$rate" "CRITICAL"
            done <<< "$top_threats"
        fi
    fi
}

# Clean up stale process tracking data
cleanup_process_data() {
    # Remove data for non-existent processes
    local stale_pids=()
    
    # Check each tracked process
    for pid in "${!process_children_count[@]}"; do
        if [ ! -e "/proc/$pid" ]; then
            stale_pids+=("$pid")
        fi
    done
    
    # Remove stale entries
    for pid in "${stale_pids[@]}"; do
        unset process_children_count["$pid"]
        unset process_prev_count["$pid"]
        unset process_growth_rate["$pid"]
        unset process_cmd_cache["$pid"]
        unset process_user_cache["$pid"]
        unset process_start_time["$pid"]
        unset process_child_cmd_count["$pid"]
    done
    
    # Limit cache size for long-running processes
    if [ ${#process_children_count[@]} -gt $PROCESS_HISTORY_SIZE ]; then
        # Keep exempt processes and remove oldest non-exempt
        local non_exempt_pids=()
        for pid in "${!process_children_count[@]}"; do
            if [ -z "${process_exempt[$pid]}" ]; then
                non_exempt_pids+=("$pid")
            fi
        done
        
        # Sort by monitoring start time and keep only the newest
        local pids_to_keep=${#non_exempt_pids[@]}
        if [ $pids_to_keep -gt $((PROCESS_HISTORY_SIZE / 2)) ]; then
            # Remove oldest half of non-exempt processes
            local pids_to_remove=$((pids_to_keep - (PROCESS_HISTORY_SIZE / 2)))
            
            # This is a simplified approach - in a real implementation we would sort by timestamp
            local count=0
            for pid in "${non_exempt_pids[@]}"; do
                if [ $count -lt $pids_to_remove ]; then
                    unset process_children_count["$pid"]
                    unset process_prev_count["$pid"]
                    unset process_growth_rate["$pid"]
                    unset process_cmd_cache["$pid"]
                    unset process_user_cache["$pid"]
                    unset process_start_time["$pid"]
                    unset process_child_cmd_count["$pid"]
                    count=$((count + 1))
                else
                    break
                fi
            done
        fi
    fi
}

# Main function - enhanced with advanced detection
main() {
    log_message "Shell Fork Bomb Terminator Professional started" "CRITICAL"
    
    # Use lower CPU priority
    renice 10 $$ > /dev/null 2>&1
    ionice -c3 -p $$ > /dev/null 2>&1
    
    # Load cache
    load_cache
    
    # Counter for maintenance operations
    local counter=0
    local report_interval=24  # Generate report every 24 cycles
    local cleanup_interval=5  # Clean caches every 5 cycles
    
    while true; do
        # Get all running processes
        local fork_bomb_count=0
        
        # Process each PID
        for pid in $(find /proc -maxdepth 1 -regex '/proc/[0-9]+' -printf "%f\n" 2>/dev/null); do
            # Skip if not a valid PID
            if ! [[ "$pid" =~ ^[0-9]+$ ]]; then
                continue
            fi
            
            # Skip kernel processes
            if [ "$pid" -le 2 ]; then
                continue
            fi
            
            # Get child count for this process
            local child_count=$(get_child_count "$pid")
            process_children_count["$pid"]=$child_count
            
            # Check if this is a fork bomb
            if [ $child_count -gt 0 ] && is_fork_bomb "$pid" "$child_count"; then
                terminate_fork_bomb "$pid" "$child_count" "${process_growth_rate[$pid]}"
                fork_bomb_count=$((fork_bomb_count + 1))
            fi
        done
        
        # Log summary if fork bombs found
        if [ $fork_bomb_count -gt 0 ]; then
            log_message "Scan complete: Detected and terminated $fork_bomb_count fork bombs" "CRITICAL"
        fi
        
        # Increment counter and perform maintenance periodically
        counter=$((counter + 1))
        
        # Clean process data periodically
        if [ $((counter % cleanup_interval)) -eq 0 ]; then
            cleanup_process_data
        fi
        
        # Save cache periodically
        if [ $((counter % 10)) -eq 0 ]; then
            save_cache
        fi
        
        # Generate threat report periodically
        if [ $((counter % report_interval)) -eq 0 ]; then
            generate_threat_report
        fi
        
        # Use adaptive sleep to reduce system load
        if [ $fork_bomb_count -gt 0 ]; then
            # More frequent checks if fork bombs detected
            sleep 5
        else
            sleep $SCAN_INTERVAL
        fi
    done
}

# Trap signals for clean exit and reporting
trap "save_cache; generate_threat_report; log_message 'Shell Fork Bomb Terminator Hardened Fangbull stopped' 'CRITICAL'; exit 0" SIGTERM SIGINT

main 