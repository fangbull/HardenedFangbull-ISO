#!/bin/bash

# Optimize All IDS Scripts - Hardened Fangbull
# Bulk optimization script for all IDS components
# Author: root0emir
# Last Modified: 2025-01-08

# List of IDS scripts to optimize (excluding already optimized ones)
IDS_SCRIPTS=(
    "hidden_binary_execution_catcher"
    "malscript_exterminator"
    "memory_resident_process_checker"
    "netlink_monitor_watchdog"
    "rootshell_injection_mitigator"
    "shell_fork_bomb_terminator"
    "tty_hijack_detector"
    "zombie_process_hunter"
)

# Base directory for scripts
SCRIPT_DIR="/usr/local/bin"

# Function to optimize a single IDS script
optimize_ids_script() {
    local script_name="$1"
    local script_path="$SCRIPT_DIR/$script_name"
    
    if [ ! -f "$script_path" ]; then
        echo "Warning: Script $script_name not found"
        return 1
    fi
    
    echo "Optimizing $script_name..."
    
    # Create backup
    cp "$script_path" "$script_path.backup.$(date +%Y%m%d_%H%M%S)"
    
    # Create optimized version
    cat > "$script_path.optimized" << 'EOF'
#!/bin/bash

# SCRIPT_TITLE - Hardened Fangbull (Optimized)
# SCRIPT_DESCRIPTION
# Performance optimized with efficient logging

# Load optimized log manager
source /usr/local/bin/fangbull-log-manager 2>/dev/null || {
    echo "Error: fangbull-log-manager not found" >&2
    exit 1
}

# Configuration with optimized settings
COMPONENT_NAME="COMPONENT_PLACEHOLDER"
CACHE_FILE="/var/log/fangbull-ids/COMPONENT_PLACEHOLDER.cache"
SAMPLE_DIR="/var/log/fangbull-ids/COMPONENT_PLACEHOLDER_samples"
INTEL_DB="/var/log/fangbull-ids/COMPONENT_PLACEHOLDER_intel.db"
SCAN_INTERVAL=60      # Optimized interval
SEVERITY_THRESHOLD=75 # Reduced false positives
MAX_CONCURRENT_SCANS=2 # Limit concurrent operations

# Performance counters
declare -A PERF_COUNTERS=(
    ["scans_completed"]=0
    ["threats_detected"]=0
    ["false_positives"]=0
    ["cache_hits"]=0
)

# Create required directories
mkdir -p "$(dirname "$CACHE_FILE")" 2>/dev/null
mkdir -p "$SAMPLE_DIR" 2>/dev/null
mkdir -p "$(dirname "$INTEL_DB")" 2>/dev/null

# Optimized logging function
log_message() {
    local message="$1"
    local level="${2:-INFO}"
    fangbull_log "$level" "$COMPONENT_NAME" "$message"
}

# Optimized cache management
manage_performance_cache() {
    manage_cache "$CACHE_FILE"
    cleanup_samples "$SAMPLE_DIR"
    
    # Update performance counters every 50 scans
    if [ $((${PERF_COUNTERS["scans_completed"]} % 50)) -eq 0 ]; then
        local stats_file="/var/log/fangbull-ids/COMPONENT_PLACEHOLDER_performance.stats"
        {
            echo "Scans Completed: ${PERF_COUNTERS["scans_completed"]}"
            echo "Threats Detected: ${PERF_COUNTERS["threats_detected"]}"
            echo "Cache Hits: ${PERF_COUNTERS["cache_hits"]}"
            echo "Last Update: $(date)"
        } > "$stats_file"
    fi
}

# Fast hash-based cache lookup
check_cache() {
    local item="$1"
    local item_hash=$(echo "$item" | sha256sum 2>/dev/null | cut -d' ' -f1)
    
    if [ -n "$item_hash" ] && [ -f "$CACHE_FILE" ] && grep -q "^$item_hash" "$CACHE_FILE" 2>/dev/null; then
        PERF_COUNTERS["cache_hits"]=$((${PERF_COUNTERS["cache_hits"]} + 1))
        return 0  # Item already processed
    fi
    
    return 1  # Item needs processing
}

# Add item to cache
add_to_cache() {
    local item="$1"
    local result="$2"
    local item_hash=$(echo "$item" | sha256sum 2>/dev/null | cut -d' ' -f1)
    
    if [ -n "$item_hash" ]; then
        echo "$item_hash:$result:$(date +%s)" >> "$CACHE_FILE"
    fi
}

EOF

    # Extract original script content (skip first few lines and old log functions)
    sed -n '/^# Configuration/,$p' "$script_path" | \
    sed '/^LOG_FILE=/d' | \
    sed '/^LOG_MAX_SIZE=/d' | \
    sed '/^rotate_log()/,/^}/d' | \
    sed '/^log_message()/,/^}/d' | \
    sed 's/SCAN_INTERVAL=[0-9]*/SCAN_INTERVAL=60/' | \
    sed 's/THRESHOLD=[0-9]*/THRESHOLD=75/' | \
    sed 's/SEVERITY_THRESHOLD=[0-9]*/SEVERITY_THRESHOLD=75/' >> "$script_path.optimized"
    
    # Replace component-specific placeholders
    local component_name=$(echo "$script_name" | sed 's/_/-/g')
    sed -i "s/COMPONENT_PLACEHOLDER/$component_name/g" "$script_path.optimized"
    
    # Update script title and description
    local title=$(head -n 5 "$script_path" | grep "^#" | head -n 2 | tail -n 1 | sed 's/^# //')
    local description=$(head -n 10 "$script_path" | grep "^#" | grep -v "#!/" | head -n 3 | tail -n 1 | sed 's/^# //')
    
    sed -i "s/SCRIPT_TITLE/$title/" "$script_path.optimized"
    sed -i "s/SCRIPT_DESCRIPTION/$description/" "$script_path.optimized"
    
    # Add optimized main function wrapper
    cat >> "$script_path.optimized" << 'EOF'

# Optimized main function wrapper
optimized_main() {
    log_message "Starting optimized scan cycle" "INFO"
    
    # Set process limits for resource management
    renice 15 $$ > /dev/null 2>&1
    ionice -c 3 -p $$ > /dev/null 2>&1
    
    # Initialize performance monitoring
    local start_time=$(date +%s)
    local scan_count=0
    
    while true; do
        local cycle_start=$(date +%s)
        scan_count=$((scan_count + 1))
        
        # Performance management
        manage_performance_cache
        
        # Call original main function if it exists
        if declare -f main >/dev/null 2>&1; then
            main
        fi
        
        # Update performance counters
        PERF_COUNTERS["scans_completed"]=$((${PERF_COUNTERS["scans_completed"]} + 1))
        
        # Adaptive sleep based on system load
        local cycle_time=$(($(date +%s) - cycle_start))
        local sleep_time=$SCAN_INTERVAL
        
        if [ $cycle_time -gt 30 ]; then
            sleep_time=$((SCAN_INTERVAL + 30))  # Slower if system is loaded
        fi
        
        # Log performance every 50 scans
        if [ $((scan_count % 50)) -eq 0 ]; then
            local runtime=$(($(date +%s) - start_time))
            log_message "Performance: $scan_count scans in ${runtime}s, ${PERF_COUNTERS["cache_hits"]} cache hits" "INFO"
        fi
        
        sleep $sleep_time
    done
}

# Start optimized main if script is executed directly
if [ "${BASH_SOURCE[0]}" = "${0}" ]; then
    optimized_main "$@"
fi
EOF

    # Replace original script with optimized version
    mv "$script_path.optimized" "$script_path"
    chmod +x "$script_path"
    
    echo "✓ Optimized $script_name"
}

# Main optimization process
main() {
    echo "Starting bulk IDS optimization..."
    echo "Scripts to optimize: ${#IDS_SCRIPTS[@]}"
    
    local success_count=0
    local total_count=${#IDS_SCRIPTS[@]}
    
    for script in "${IDS_SCRIPTS[@]}"; do
        if optimize_ids_script "$script"; then
            success_count=$((success_count + 1))
        fi
    done
    
    echo ""
    echo "Optimization completed!"
    echo "Successfully optimized: $success_count/$total_count scripts"
    
    # Update systemd services to use optimized scripts
    echo "Updating systemd service files..."
    for script in "${IDS_SCRIPTS[@]}"; do
        local service_file="/etc/systemd/system/${script//_/-}.service"
        if [ -f "$service_file" ]; then
            sed -i "s|ExecStart=.*$script|ExecStart=$SCRIPT_DIR/$script|" "$service_file"
        fi
    done
    
    echo "✓ All IDS scripts optimized and ready for deployment!"
}

# Run main function
main "$@"
